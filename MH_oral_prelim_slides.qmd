---
title: "Statistical Tools for Large-Scale Spatiotemporal Transportation Data"
author: "Marie Hardt"
date: "2025-10-09"
institute: "Iowa State University"
bibliography: "`r rbbt::bbt_write_bib('slidereferences.bib', keys=rbbt::bbt_detect_citations(here::here('problem_overview.qmd')),
   ignore = stringr::str_subset(rbbt::bbt_detect_citations(here::here('problem_overview.qmd')), '(^fig-|^tbl-|^eq-|^sec-|^lst-|^thm-|^lem-|^cor-|^prp-|^cnj-|^def-|^exm-|^exr-)'), overwrite = TRUE, library_id='Graphics-Research', translator='bibtex')`"
format: 
  revealjs:
    theme: simple
    slide-number: true
---

```{r setup}
#| echo: false
#| warning: false
#| message: false
library(rbbt)
library(tidyverse)
library(leaflet)
library(sf)
library(glue)
# remotes::install_github("hardtme/DrivePlotR)
library(DrivePlotR)
library(tmap)
tmap_mode("plot")
# remotes::install_github("dill/emoGG")
library(emoGG)
library(gpsdriving)
library(fontawesome)

fa_by_name <- function(name, fill = "blue", stroke = "white", stroke_width = "1px") {
  fa_png(
    name = name,
    fill = fill,
    fill_opacity = 1,
    stroke = stroke,
    stroke_width = stroke_width, 
    stroke_opacity = 1,
    height = 512,
    width = 512
  )
}

example_tmap <- function(basemap = "CartoDB.VoyagerNoLabels",
                         road_system,
                         bbox,
                         road_system_color = "tan",
                         road_system_lwd = 10,
                         og_points,
                         og_points_color = "blue",
                         new_points,
                         new_points_color = "red",
                         point_size = 1,
                         point_fill_alpha = 1,
                         match_lines,
                         match_lines_color = "black"){
ex_tmap <- tm_basemap(server = basemap)+
  tm_shape(road_system, bbox = bbox)+
  tm_lines(col = road_system_color, lwd = road_system_lwd)+
  tm_shape(match_lines, bbox = bbox)+
  tm_lines(col = match_lines_color)+
  tm_shape(og_points, bbox = bbox)+
  tm_dots(size = point_size, fill = og_points_color, fill_alpha = point_fill_alpha, 
          group = "original", group.control = "none")+
  tm_shape(new_points, bbox = bbox)+
  tm_dots(size = point_size, fill = new_points_color, fill_alpha = point_fill_alpha,
          group = "shifted", group.control = "none")
return(ex_tmap)
}
```

# Spatiotemporal Transportation Data

## Vehicle Trajectory Data

* Collected from vehicles as they are driven.

* Points observed regularly (e.g., every 1-3 sec. for our data sources).

## Typical Variables

* Location (latitude/longitude).
  
* Speed.
  
* Heading.

* Etc.

## Sources

* Naturalistic driving studies (NDS)

  - Instrumentation installed in study participants' vehicles.

* Connected vehicles

  - Instrumentation built into the vehicle by original manufacturer.

## Use Cases

* Studying driving behavior.

* Driving maneuver detection.

* Work zone impact/performance.

* Etc.

# GPS Data

## Units Are Important!

It's 25 degrees outside today.

* Fahrenheit: ðŸ¥¶

* Celsius: ðŸ˜Ž

## Coordinate Reference Systems[^gps]

* Describe how latitude/longitude coordinates relate to real places on the Earth's surface.

* Ensure locations are properly located because they are related to the correct ellipsoidal approximation of the Earth.

* CRS for GPS data: WGS 84.

[^gps]: @iliffeDatumsMapProjections2008

## Projected Coordinate Systems

* Project coordinates from the Earth's surface (3-D) down to 2 dimensions.

* 3-D surfaces can't be projected down to 2 dimensions without distortion (but that's okay).

* Example: WGS 84 Web Mercator projection for coordinates using the WGS 84 projection.

## GPS Overview (Simplified)

* Part of Global Navigation Satellite System (GNSS).

* Satellite constellation orbits the Earth.

* Ground-based monitoring stations track satellites and transmit satellite locations back to the satellites.

* Satellites transmit their positions to receivers.

* Receivers determine the travel time of the signal from the satellite and thus the distance to the satellite. 

## Examples of GPS Satellite Constellation Geometries

:::{layout-ncol=2}

```{r}
#| echo: false
#| fig-cap: "Poor Satellite Geometry"

receiver <- data.frame( x = 0, y = 0)

bad_satellites <- data.frame(x = c(-0.7, -0.3, -0.5, -0.8),
                             y = c(7.5, 9.75, 9, 6.5))

good_satellites <- data.frame(x = c(1, -1, -0.3, 0.4),
                         y = c(7, 8, 10, 9.5))

bad_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = bad_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = bad_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
bad_sats
```

```{r}
#| echo: false
#| fig-cap: "Good Satellite Geometry"

good_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = good_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = good_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
good_sats

```
:::

## Dilution of Precision (DOP)[^dop]

* Measure of GPS data quality.

* Different types include:

  - Position DOP (PDOP).
  
  - Horizontal DOP (HDOP).
  
  - Vertical DOP (VDOP).
  
[^dop]: @isikIntegrityAnalysisGPSBased2020
  
## DOP Values and Data Quality

| **DOP Value**                 | <1   | 1 - 2     | 2 - 5    | 5 - 10   | 10 - 20 | >20 |
|-------------------|---------|---------|----------|----------|---------|---------|
| **Location Data Quality** | Ideal | Excellent | Very Good | Moderate | Fair    | Poor |

Scale relating the value of dilution of precision (DOP) coefficients to location data quality [@isikIntegrityAnalysisGPSBased2020].

## GPS Data Issues

* Poor GPS signal â†’ position errors.

* Position errors â†’ velocity errors â†’ acceleration errors.

* Low DOP doesn't always mean good quality GPS data.

* GPS headings are unreliable at low speeds.

## GPS Drift Example

PDOP values: 1.63 to 2.36 (Excellent to Very Good)

```{r}
#| echo: false
#| eval: true

data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

exdrive <- nds_data_sf |>
  filter(drive == 23)

exdrive_plot <- exdrive |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

exdrive_plot <- exdrive_plot |>
  mutate(pt_label = c("Start", rep("", 8), "End"))

exdrive_bbox <- st_bbox(exdrive_plot)

exdrive_bbox_adj <- exdrive_bbox
exdrive_bbox_adj[1] <- exdrive_bbox_adj[1] - 0.0002
exdrive_bbox_adj[2] <- exdrive_bbox_adj[2] - 0.0002
exdrive_bbox_adj[3] <- exdrive_bbox_adj[3] + 0.0002
exdrive_bbox_adj[4] <- exdrive_bbox_adj[4] + 0.0002

# USGS data
data("oma_roads")
# Make exdrive example bounding box into sf object
exdrive_bbox_sf <- exdrive_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the exdrive example above
poss_matches <- oma_roads |>
  st_filter(exdrive_bbox_sf, .predicate = st_intersects)

gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels") +
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10)+
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "blue", fill_alpha = 0.9, 
          group = "original", group.control = "none")

gps_drift_tmap <- gps_drift_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.5, options = opt_tm_labels(point.label = FALSE))

gps_drift_tmap
```


# Map-Matching Problem

## Goal

Associate (erroneously) recorded locations of a moving vehicle to the road system.

## Main Problems to Solve

1. On which road is the vehicle driving? (Road selection problem)

2. Where on the road is the vehicle driving? (Position determination problem)

## Brief Overview of Map-Matching Algorithms

* Active research area since the late 20th century.

* Hundreds of MM algorithms have been proposed.

* Wide range of method complexity.


## Simple Geometric MM Algorithms

Goal: find the closest road segment to each GPS point.

* Point-to-point.

* Point-to-curve.

* Curve-to-curve.

## Example of Point-to-Point MM Algorithm

:::columns
::: {.column width="50%"}
1. Find the road corresponding to the nearest point on the road system.

2. Orthogonally project the recorded point onto the selected road.
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| fig.asp: 1
# For each GPS point, find the nearest point on each of the road segments
nearest_pts_ls <- st_nearest_points(exdrive_plot, poss_matches)

nearest_pts_ls_sf <- st_as_sf(nearest_pts_ls)

# Find the distance between the original point and the matched point
nearest_pts_ls_sf <- nearest_pts_ls_sf |>
  rename(geometry = x) |>
  mutate(dist = st_length(geometry))

nearest_pts_ls_sf_start <- lwgeom::st_startpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_ls_sf_end <- lwgeom::st_endpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

# For each starting point, find the closest matched point
nearest_pts_end_match <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id) |>
  filter(dist == min(dist))

# Get the lines between the original points and the matched points
nearest_pts_ls_match <- nearest_pts_ls_sf |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches))) |>
  group_by(id) |>
  filter(dist == min(dist))

fa_by_name("circle-exclamation", fill = "gold", stroke = "black", stroke_width = "5px")

warn_pt <- st_sfc(st_point(x = c(-95.99816, 41.25787)), crs = 4326) |>
  st_as_sf() |>
  st_cast("POINT")

warn_pt_icon <- tmap_icons("circle-exclamation.png")

mm_tmap <- example_tmap(road_system = poss_matches,
                        road_system_lwd = 20,
                        bbox = exdrive_bbox_adj,
                        og_points = exdrive_plot,
                        new_points = nearest_pts_end_match,
                        match_lines = nearest_pts_ls_match,
                        point_size = 1.5,
                        point_fill_alpha = 0.9)

mm_tmap <- mm_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(warn_pt, bbox = exdrive_bbox_adj) +
  tm_dots(size = 0.7, col = "black", fill_alpha = 1)+
  tm_symbols(shape = warn_pt_icon, size = 0.4)

mm_tmap
```
:::
:::

## Account for Vehicle Heading

* Find closest road segment, as before.

* Restrict candidate roads to have similar bearings as the vehicle heading.

## Example of Point-to-Point MM Algorithm that Accounts for Heading

:::columns
::: {.column width="50%"}
1. Of the candidate road segments that have a similar bearing to the vehicle heading, find the road corresponding to the nearest point on the road system.

2. Orthogonally project the recorded point onto the selected road.
:::

::: {.column width="50%"}
```{r}
#| echo: false
up_ca <- tmap_icons("circle-chevron-up.png")
left_ca <- tmap_icons("circle-chevron-left.png")
down_ca <- tmap_icons("circle-chevron-down.png")
right_ca <- tmap_icons("circle-chevron-right.png")

poss_match_start <- lwgeom::st_startpoint(poss_matches)
poss_match_end <- lwgeom::st_endpoint(poss_matches)

road_bearings <- map2(.x = poss_match_start, .y = poss_match_end,
                      \(x, y) lwgeom::st_geod_azimuth(st_sfc(st_point(x), st_point(y), crs = 4326)) |>
                        units::set_units("degrees")) |>
  list_c()

poss_matches <- poss_matches |>
  mutate(bearing = 360 + as.numeric(road_bearings))

nearest_pts_ls_sf_id <- nearest_pts_ls_sf |>
  mutate(ObjectID = rep(poss_matches$ObjectID, length.out = nrow(nearest_pts_ls_sf)),
         time_utc = rep(exdrive_plot$time_utc, each = nrow(poss_matches)))

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id, 
                                          exdrive_plot |> select(time_utc, gyro_heading) |> st_drop_geometry(),
                                          by = "time_utc")

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id_heading,
                                          poss_matches |> select(ObjectID, bearing) |> st_drop_geometry(),
                                          by = "ObjectID")

# Keep the points that have a heading within 45 degrees of the road segment heading
nearest_pts_heading_filter <- nearest_pts_ls_sf_id_heading |>
  mutate(abs_heading_dist = abs(gyro_heading - bearing)) |>
  filter(abs_heading_dist <= 45)

# Keep the closest point
nearest_pts_heading_filter_dist <- nearest_pts_heading_filter |>
  group_by(time_utc) |>
  filter(dist == min(dist))

nearest_pts_heading_filter_dist_start <- lwgeom::st_startpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_heading_filter_dist_end <- lwgeom::st_endpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)
```

```{r}
#| fig.asp: 1
mm_tmap_heading <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 20) +
  tm_shape(nearest_pts_heading_filter_dist, bbox = exdrive_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(exdrive_plot #|> mutate(
    #gyro_heading = 360 - gyro_heading + 90) # use compass rose instead of unit circle representation
  ) + 
  tm_dots(size = 1.5, fill = "white", group = "original", group.control = "none", fill_alpha = 1)+ 
  tm_symbols(shape = "gyro_heading", size = 0.48, 
             shape.scale = tm_scale_intervals(
               style = "fixed",
               n = 5,
               #values = list(right, up, left, down, right),
               values = list(up_ca, right_ca, down_ca, left_ca, up_ca),
               breaks = c(0, 45, 135, 225, 315, 360)),
             group = "original", group.control = "none", 
             shape.legend = tm_legend(title = "Vehicle Heading\n(0 Degrees = North)")) +
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(nearest_pts_heading_filter_dist_end, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1.5, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_heading <- mm_tmap_heading + 
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))
mm_tmap_heading
```

:::
:::

## Issues with Geometric MM Methods[^issues]

* Sensitivity to outliers.

* Unstable results in urban areas with many roads close together.

* Closest road may not be the correct road.

[^issues]: @quddusCurrentMapmatchingAlgorithms2007

## Existing Map-Matching Methods

* Naive methods

* More advanced naive methods

* Hidden Markov models

* Etc.

## Map Matching Challenges

* True path is usually unknown

* Error quantification

* Outlier sensitivity

* Etc.

# Areas of Interest

## Visualizing Telematics Data

* Relating location in time and space to other variables 

* R package `DrivePlotR`

## Processing Telematics Data

* Map matching

* Correctly locating telematics data in space (latitude/longitude on correct part of the road system) and time

## Drawing Insights from Telematics Data

For example,

* Developing driving biomarkers for age-related cognitive decline in senior citizens

* Deriving the time to complete turning maneuvers at intersections

* Quantifying the influence of work zones, crashes, etc. on traffic flow

## References


