---
title: "Statistical Tools for Large-Scale Spatiotemporal Transportation Data"
author: "Marie Hardt"
date: "2025-10-20"
institute: "Iowa State University"
bibliography: "`r rbbt::bbt_write_bib('slidereferences.bib', keys=rbbt::bbt_detect_citations(here::here('MH_oral_prelim_slides.qmd')),
   ignore = stringr::str_subset(rbbt::bbt_detect_citations(here::here('MH_oral_prelim_slides.qmd')), '(^fig-|^tbl-|^eq-|^sec-|^lst-|^thm-|^lem-|^cor-|^prp-|^cnj-|^def-|^exm-|^exr-)'), overwrite = TRUE, library_id='Graphics-Research', translator='bibtex')`"
format: 
  revealjs:
    theme: simple
    slide-number: true
    auto-stretch: false
    width: 1470
    height: 980
---

```{r setup}
#| echo: false
#| warning: false
#| message: false
library(rbbt)
library(tidyverse)
library(leaflet)
library(sf)
library(glue)
# remotes::install_github("hardtme/DrivePlotR)
library(DrivePlotR)
library(tmap)
tmap_mode("plot")
# remotes::install_github("dill/emoGG")
library(emoGG)
library(gpsdriving)
library(fontawesome)

fa_by_name <- function(name, fill = "blue", stroke = "white", stroke_width = "1px") {
  fa_png(
    name = name,
    fill = fill,
    fill_opacity = 1,
    stroke = stroke,
    stroke_width = stroke_width, 
    stroke_opacity = 1,
    height = 512,
    width = 512
  )
}

example_tmap <- function(basemap = "CartoDB.VoyagerNoLabels",
                         road_system,
                         bbox,
                         road_system_color = "tan",
                         road_system_lwd = 10,
                         og_points,
                         og_points_color = "blue",
                         new_points,
                         new_points_color = "red",
                         point_size = 1,
                         point_fill_alpha = 1,
                         match_lines,
                         match_lines_color = "black"){
ex_tmap <- tm_basemap(server = basemap)+
  tm_shape(road_system, bbox = bbox)+
  tm_lines(col = road_system_color, lwd = road_system_lwd)+
  tm_shape(match_lines, bbox = bbox)+
  tm_lines(col = match_lines_color)+
  tm_shape(og_points, bbox = bbox)+
  tm_dots(size = point_size, fill = og_points_color, fill_alpha = point_fill_alpha, 
          group = "original", group.control = "none")+
  tm_shape(new_points, bbox = bbox)+
  tm_dots(size = point_size, fill = new_points_color, fill_alpha = point_fill_alpha,
          group = "shifted", group.control = "none")
return(ex_tmap)
}
```

## About Me

### Education at Iowa State University

* B.Sc. in Mathematics and B.Sc. in Statistics (Fall 2016-Spring 2020)

* M.Sc. in Statistics (Fall 2020-Fall 2022)

* Ph.D. in Statistics (Spring 2023-present)

### Anticipated Completion

Summer 2026

### Career Aspirations

Position in industry, government agency, or research institution

## Outline

### Current Work

* Creating an open-source tool for visualizing spatiotemporal transportation data.

* Describing the relationship between older drivers' turning behavior and their cognitive status (aging normally or cognitively impaired) based on naturalistic driving data.

### Proposed Work

* Overview of the map-matching problem.

* Proposed method to estimate a vehicle's position on the road system after map-matching.

## Vehicle Trajectory Data
 
* Collected from vehicles as they are driven.

* Points observed regularly (e.g., every 1-3 sec. for our data sources).

## Open-Source Tool for Visualizing Spatiotemporal Transportation Data

* R package `DrivePlotR`.

* Interactive plot-maps relate vehicle location in time and space to other variables.

* Accepted for presentation at the Transportation Research Board Annual Meeting in January 2026.

## `DrivePlotR` Example Visualization

```{r}
#| echo: false
drive <- nds_data |> dplyr::filter(drive == 7)
drive <- drive |> 
  sf::st_as_sf(coords = c("gps_long", "gps_lat"), 
               crs = "WGS84")
drive <- drive |>
  dplyr::mutate(time_cst = lubridate::ymd_hms(time_cst, tz = "US/Central"),
                gps_minute = as.factor(lubridate::minute(time_cst)))

shared_drive <- shared_drive <- 
  crosstalk::SharedData$new(drive)

driveplot(
  shareddata = shared_drive, 
  maplabel = time_cst, colorvar = gps_minute, 
  colorpalette = "viridis", fillOpacity = 1, 
  time = time_cst, y1 = speed_mph, 
  y2 = gyro_heading_raw, 
  y3 = gps_pdop, 
  timelabel = "Time", y1label = "Speed (MPH)", 
  y2label = "Gyro Heading", 
  y3label = "GPS PDOP", showlegend = TRUE, 
  legendtitle = "Minute", 
  spacing = 0.05)
```

## Naturalistic Driving Studies (NDS)

* Instrumentation installed in study participants' vehicles monitors their driving.

  - Video cameras.
  
  - GPS receiver.
  
  - Accelerometer.
  
  - Gyroscope.
  
  - Etc.
  
## Data Collected

(Depending on instrumentation)

* Video of driver.

* Video of roadway.

* Latitude/longitude.

* Time.

* Speed.

* Heading.

* Measure(s) of GPS data quality.

* Engine RPMs.

* Etc.
  
## Notable NDS Examples

* Second Strategic Highway Research Program (SHRP 2) [@campbellSHRP2Naturalistic2012].
  
    - Participants aged 16 and older from 6 sites across the US.
    
    - Goal: assess the role of driver behavior in traffic safety, particularly crashes.
  
* Longitudinal Research on Aging Drivers (LongROAD) [@liLongitudinalResearchAging2017].

  - Participants aged 65-79 from 5 sites across the US.
  
  - Goal: understand unique factors affecting older drivers, including the age-related functional decline and self-regulatory driving behaviors.
  
## NDS Analyzed in this Research

* Conducted by the University of Nebraska Medical Center (UNMC).

* Supported by

  - National Institutes of Health (NIH).
  
  - National Institute on Aging (NIA 5R01AG17177-18).
  
  - UNMC Mind \& Brain Health Labs.
  
* Participants aged 65-90 from the Omaha, Nebraska, area.
  
* Goal: use driving data from older drivers to develop biomarkers for early detection and monitoring of cognitive decline.

## Turns and Downturns in Aging Drivers

:::{.column width="60%"}
* Analysis of driving data from the UNMC NDS.

* Motivation: 

  - Turning across traffic is a challenging maneuver for older drivers, but intentional avoidance is rarely self-reported [@molnarRelationshipSelfRegulationDrivingRelated2008; @molnarSelfregulationDrivingOlder2013; @beckExaminingPatternsDriving2022].
  
  - @diDetectingMildCognitive2023 analyzed data from the LongROAD NDS and found that the ratio of right turns to left turns predicted cognitive impairment in older drivers.
  
* Goal: quantify the association between an older driver's cognitive status (aging normally or cognitively impaired) and their odds of making a left turn.

:::

:::{.column width="40%"}
![](turns_paper_screenshot.png)

:::

## Simple Turn Detection Method

Gyroscopic heading changes of $\pm 10^{\circ}$ or more in 1 second were classified as turns (developed based on `DrivePlotR` visualizations).

::: {layout-ncol=2}

```{r}
#| fig.height: 6
# remotes::install_github("heike/ggtransport")
library(ggtransport)
library(units)
speed_cone <- data.frame(
  speed = set_units(10*1:5, miles/hour),
  time = set_units(rep(1,5), second)
) |> mutate(
  distance = (speed*time) |> set_units(feet) |> as.numeric(),
  start=-10/180*pi + pi/2, # rotate to the right by 90 degrees
  end=10/180*pi + pi/2,
  offset_ft = set_units(distance, feet)*sin(10*pi/180), 
  offset_m = set_units(offset_ft, m)) 

carplot <- draw_multi_lane_road(road_length = 100, lanes_per_direction = 1, lane_width = 12) +
  geom_segment(aes(x = -35+distance*cos(10/180*pi), 
                   xend = -35+distance*cos(10/180*pi), 
                   y = -as.numeric(offset_ft)-6, 
                   yend = as.numeric(offset_ft)-6), 
               data = speed_cone, linewidth = 0.5,
               colour = "grey30",
               arrow=grid::arrow(ends="both", type = "closed", length = unit(0.15, "cm"))) + 
  ggforce::geom_arc_bar(
    aes(x0 = -35, y0 = -6, r0 = 0, r = distance, 
        start=start, end=end), data =speed_cone,
        fill="black", alpha = 0.15, colour="grey40") + 
    draw_car(x = -35, y = -6) + 
  geom_text(aes(y = -6, x = -35+ distance-speed_cone$distance[1]/2, label=speed), 
             colour = "white", size = 6,
             data = speed_cone[-1,]) + 
  geom_text(aes(y = -6, x = -35+6+ distance-speed_cone$distance[1]/2, label="mph"), 
             colour = "white", size = 3,
             data = speed_cone[-1,])
carplot
```

```{r}
library(kableExtra)
speed_cone |>
  select(speed, offset_ft, offset_m) |> 
  mutate(
    speed = as.numeric(speed),
    across(2:3, function(x) sprintf("± %02.1f",as.numeric(x)))) |>
  knitr::kable(align = "r", col.names = c("speed [mph]", "offset [ft]", "offset [m]")) 
```

:::

## Create Ordinal Variable for Cognitive Status

Define cognitive prognosis classes based on participants' cognitive diagnosis at baseline and the 1-year follow-up assessment.

1. Normal → Normal (stable normal).

2. Normal → MCI (incident MCI).

3. MCI → MCI (stable MCI).

4. MCI → AD (progression to dementia).

## Modeling Approach

* Use mixed-effects logistic regression to use cognitive prognosis class to predict whether a turn was a left or right turn (random effect for participant).

* Confirmatory analysis with ordinal logistic regression using number of drives, left-to-right turn ratio, sex, and age to predict cognitive prognosis class.

* Results: older drivers who are experiencing greater cognitive impairment have reduced odds of turning left.

* Limitations

  - Noisy signal.
  
  - Low number of participants.
  
  - Simple turn detection method.
  
  - Simple model.

## Similar Data Source: Connected Vehicles

* Instrumentation built into the vehicle by original manufacturer (no cameras).

* Usually less frequent observations than NDS.

* Usually fewer variables collected than NDS:

  - Latitude/longitude.
  
  - Time.
  
  - Speed.
  
  - Heading.
  
![](cv_example.png)

## Use Cases

Necessary level of GPS precision depends on the use case.

* Only need road information to

  - Calculate traffic volume for a road segment.
  
  - Assess the impact of a work zone on a road segment on vehicle speeds.
  
* Precise location estimates are needed to

  - Determine the time taken to turn (need to identify the approach, waiting period, actual turn, and when the turn is complete).
  
  - Compare a vehicle's stop location with the stop bar on the road.

# GPS Data

<!-- ## Coordinate Reference Systems [@iliffeDatumsMapProjections2008] -->

<!-- * Describe how latitude/longitude coordinates relate to real places on the Earth's surface. -->

<!-- * Ensure locations are properly located because they are related to the correct ellipsoidal approximation of the Earth. -->

<!-- * CRS for GPS data: WGS 84. -->

<!-- ## Projected Coordinate Systems -->

<!-- * Project coordinates from the Earth's surface (3-D) down to 2 dimensions. -->

<!-- * 3-D surfaces can't be projected down to 2 dimensions without distortion (but that's okay). -->

<!-- * Example: WGS 84 Web Mercator projection for coordinates using the WGS 84 CRS. -->

## GPS Overview (Simplified)

<!-- * Part of Global Navigation Satellite System (GNSS). -->

<!-- * Ground-based monitoring stations track satellites and transmit satellite locations back to the satellites. -->

<!-- * Receivers determine the travel time of the signal from the satellite and thus the distance to the satellite.  -->

* Satellite constellation orbits the Earth.

* Satellites transmit their positions to receivers.

* Receivers determine their position based on the signals received from the satellite.

* 4 satellites are needed to get a position fix.

## Examples of GPS Satellite Constellation Geometries

:::{layout-ncol=2}

```{r}
#| echo: false
#| fig-cap: "Poor Satellite Geometry"

receiver <- data.frame( x = 0, y = 0)

bad_satellites <- data.frame(x = c(-0.7, -0.3, -0.5, -0.8),
                             y = c(7.5, 9.75, 9, 6.5))

good_satellites <- data.frame(x = c(1, -1, -0.3, 0.4),
                         y = c(7, 8, 10, 9.5))

bad_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = bad_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = bad_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
bad_sats
```

```{r}
#| echo: false
#| fig-cap: "Good Satellite Geometry"

good_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = good_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = good_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
good_sats

```
:::

## Dilution of Precision (DOP) [@isikIntegrityAnalysisGPSBased2020]

* Measure of GPS data quality.

* Different types include:

  - Position DOP (PDOP).
  
  - Horizontal DOP (HDOP).
  
  - Vertical DOP (VDOP).

## DOP Values and Data Quality

| **DOP Value**                 | <1   | 1 - 2     | 2 - 5    | 5 - 10   | 10 - 20 | >20 |
|-------------------|---------|---------|----------|----------|---------|---------|
| **Location Data Quality** | Ideal | Excellent | Very Good | Moderate | Fair    | Poor |

Scale relating the value of dilution of precision (DOP) coefficients to location data quality [@isikIntegrityAnalysisGPSBased2020].

## GPS Data Issues


::: {.column width="50%"}
* Poor GPS signal → position errors.

* Position errors → velocity errors → acceleration errors.

* GPS headings are unreliable at low speeds.

* Low DOP doesn't always mean good quality GPS data. 
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| eval: true
#| fig.asp: 1
#| fig.cap: "PDOP values: 1.63 to 2.36 (Excellent to Very Good)"
data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

exdrive <- nds_data_sf |>
  filter(drive == 23)

exdrive_plot <- exdrive |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

exdrive_plot <- exdrive_plot |>
  mutate(pt_label = c("Start", rep("", 8), "End"))

exdrive_bbox <- st_bbox(exdrive_plot)

exdrive_bbox_adj <- exdrive_bbox
exdrive_bbox_adj[1] <- exdrive_bbox_adj[1] - 0.0002
exdrive_bbox_adj[2] <- exdrive_bbox_adj[2] - 0.0002
exdrive_bbox_adj[3] <- exdrive_bbox_adj[3] + 0.0002
exdrive_bbox_adj[4] <- exdrive_bbox_adj[4] + 0.0002

# USGS data
data("oma_roads")
# Make exdrive example bounding box into sf object
exdrive_bbox_sf <- exdrive_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the exdrive example above
poss_matches <- oma_roads |>
  st_filter(exdrive_bbox_sf, .predicate = st_intersects)

gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels") +
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 20)+
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1.5, fill = "blue", fill_alpha = 0.9, 
          group = "original", group.control = "none")

gps_drift_tmap <- gps_drift_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.5, options = opt_tm_labels(point.label = FALSE))

gps_drift_tmap
```
:::


# Map-Matching Problem

## Goal

Associate (erroneously) recorded locations of a moving vehicle to the road system.

## Main Problems to Solve

1. On which road is the vehicle driving? (Road selection problem)

2. Where on the road is the vehicle driving? (Position determination problem)

## Brief Overview of Map-Matching Algorithms

* Active research area since the early 1990s.

* Hundreds of MM algorithms have been proposed.

* Wide range of method complexity.


## Simple Geometric MM Algorithms

Goal: find the closest road segment to each GPS point.

* Point-to-point.

* Point-to-curve.

* Curve-to-curve.

## Example of Point-to-Point MM Algorithm

:::columns
::: {.column width="50%"}
1. Find the road corresponding to the nearest point on the road system.

2. Orthogonally project the recorded point onto the selected road.
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| fig.asp: 1
# For each GPS point, find the nearest point on each of the road segments
nearest_pts_ls <- st_nearest_points(exdrive_plot, poss_matches)

nearest_pts_ls_sf <- st_as_sf(nearest_pts_ls)

# Find the distance between the original point and the matched point
nearest_pts_ls_sf <- nearest_pts_ls_sf |>
  rename(geometry = x) |>
  mutate(dist = st_length(geometry))

nearest_pts_ls_sf_start <- lwgeom::st_startpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_ls_sf_end <- lwgeom::st_endpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

# For each starting point, find the closest matched point
nearest_pts_end_match <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id) |>
  filter(dist == min(dist))

# Get the lines between the original points and the matched points
nearest_pts_ls_match <- nearest_pts_ls_sf |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches))) |>
  group_by(id) |>
  filter(dist == min(dist))

#fa_by_name("circle-exclamation", fill = "gold", stroke = "black", stroke_width = "5px")

# warn_pt <- st_sfc(st_point(x = c(-95.99816, 41.25787)), crs = 4326) |>
#   st_as_sf() |>
#   st_cast("POINT")

#warn_pt_icon <- tmap_icons("circle-exclamation.png")

mm_tmap <- example_tmap(road_system = poss_matches,
                        road_system_lwd = 20,
                        bbox = exdrive_bbox_adj,
                        og_points = exdrive_plot,
                        new_points = nearest_pts_end_match,
                        match_lines = nearest_pts_ls_match,
                        point_size = 1.5,
                        point_fill_alpha = 0.9)

mm_tmap <- mm_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))#+
  #tm_shape(warn_pt, bbox = exdrive_bbox_adj) +
  #tm_dots(size = 0.7, col = "black", fill_alpha = 1)+
  #tm_symbols(shape = warn_pt_icon, size = 0.4)

mm_tmap
```
:::
:::

## Account for Vehicle Heading

* Find closest road segment, as before.

* Restrict candidate roads to have similar bearings as the vehicle heading.

## Example of Point-to-Point MM Algorithm that Accounts for Heading

:::columns
::: {.column width="50%"}
1. Of the candidate road segments that have a similar bearing to the vehicle heading, find the road corresponding to the nearest point on the road system.

2. Orthogonally project the recorded point onto the selected road.
:::

::: {.column width="50%"}
```{r}
#| echo: false
up_ca <- tmap_icons("circle-chevron-up.png")
left_ca <- tmap_icons("circle-chevron-left.png")
down_ca <- tmap_icons("circle-chevron-down.png")
right_ca <- tmap_icons("circle-chevron-right.png")

poss_match_start <- lwgeom::st_startpoint(poss_matches)
poss_match_end <- lwgeom::st_endpoint(poss_matches)

road_bearings <- map2(.x = poss_match_start, .y = poss_match_end,
                      \(x, y) lwgeom::st_geod_azimuth(st_sfc(st_point(x), st_point(y), crs = 4326)) |>
                        units::set_units("degrees")) |>
  list_c()

poss_matches <- poss_matches |>
  mutate(bearing = 360 + as.numeric(road_bearings))

nearest_pts_ls_sf_id <- nearest_pts_ls_sf |>
  mutate(ObjectID = rep(poss_matches$ObjectID, length.out = nrow(nearest_pts_ls_sf)),
         time_utc = rep(exdrive_plot$time_utc, each = nrow(poss_matches)))

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id, 
                                          exdrive_plot |> select(time_utc, gyro_heading) |> st_drop_geometry(),
                                          by = "time_utc")

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id_heading,
                                          poss_matches |> select(ObjectID, bearing) |> st_drop_geometry(),
                                          by = "ObjectID")

# Keep the points that have a heading within 45 degrees of the road segment heading
nearest_pts_heading_filter <- nearest_pts_ls_sf_id_heading |>
  mutate(abs_heading_dist = abs(gyro_heading - bearing)) |>
  filter(abs_heading_dist <= 45)

# Keep the closest point
nearest_pts_heading_filter_dist <- nearest_pts_heading_filter |>
  group_by(time_utc) |>
  filter(dist == min(dist))

nearest_pts_heading_filter_dist_start <- lwgeom::st_startpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_heading_filter_dist_end <- lwgeom::st_endpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)
```

```{r}
#| fig.asp: 1
mm_tmap_heading <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 20) +
  tm_shape(nearest_pts_heading_filter_dist, bbox = exdrive_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(exdrive_plot #|> mutate(
    #gyro_heading = 360 - gyro_heading + 90) # use compass rose instead of unit circle representation
  ) + 
  tm_dots(size = 1.5, fill = "white", group = "original", group.control = "none", fill_alpha = 1)+ 
  tm_symbols(shape = "gyro_heading", size = 0.48, 
             shape.scale = tm_scale_intervals(
               style = "fixed",
               n = 5,
               #values = list(right, up, left, down, right),
               values = list(up_ca, right_ca, down_ca, left_ca, up_ca),
               breaks = c(0, 45, 135, 225, 315, 360)),
             group = "original", group.control = "none", 
             shape.legend = tm_legend(title = "Vehicle Heading\n(0 Degrees = North)")) +
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(nearest_pts_heading_filter_dist_end, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1.5, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_heading <- mm_tmap_heading + 
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))
mm_tmap_heading
```

:::
:::

## Issues with Geometric MM Algorithms[@quddusCurrentMapmatchingAlgorithms2007]

* Sensitivity to outliers.

* Unstable results in urban areas with many roads close together.

* Closest road may not be the correct road.

## More Advanced MM Algorithms

* Vast array of more sophisticated MM algorithms for selecting the road.

* Seminal work: algorithm by @newsonHiddenMarkovMap2009 using hidden Markov models to select the road.

## Brief Overview of Newson and Krumm's HMM Algorithm

* Input data:

  - Latitude/longitude coordinates from the vehicle trajectory (no other covariates).
  
  - Representation of the road network as a graph of nodes (intersections, dead ends, and road name changes) and edges (road segments between nodes).
  
* HMM states: road segments

* HMM state measurements: recorded GPS vehicle locations.

* Measurement/emission probabilities (probabilities that GPS points came from a road segment) based on distance from GPS points to road segments.

* Transition probabilities (probabilities of switching road segments between two observations) based on connectivity of the road system and distance between consecutive GPS points.

* Used the Viterbi algorithm to find the best path through the HMM lattice.

## Position Determination Problem

* Has not received much attention in the MM literature.

* Important for applications.

## Position Determination Methods in the Literature

* Orthogonal projection: still very popular even though @greenfeldMatchingGPSObservations2002 noted that the projection onto the road system may not correspond to the vehicle's true location.

* @quddusGeneralMapMatching2003: weighted average of the orthogonal projection point and another point derived from the vehicle speed and the bearing of the selected road (method also used in @ochiengMapmatchingComplexUrban2003 and @quddusHighAccuracyFuzzy2006).

* @kimEfficientUseDigital2000: Kalman filter to update vehicle location predictions based on elapsed time and new observed locations.

# Proposed Work

## Develop a New Way to Solve the Position Determination Problem in Map-Matching

After using any MM algorithm to select the road, use the new method to determine the vehicle's position on the selected road.

## Linkage Problem Approach

### Setup (based on @taylorFastBayesianRecord2024)

* Link between:

  - Recorded GPS vehicle locations.
  
  - Corresponding road segments identified by a map-matching algorithm.
  
* Common fields:

  - Location (latitude/longitude).
  
  - Heading/bearing.
  
* Other fields from vehicle trajectory:

  - Observation time.
  
  - Speed.
  
  - Etc.
  
## Linkage Problem Approach

### Proposed Methodology

* Establish similarity metrics between common fields, e.g.,

  - Distance between recorded GPS point and the road segment.
  
  - "Closeness" in heading between the vehicle and the road segments.
  
* Define a distance metric (e.g., Euclidean distance).

* Minimize the distance metric while accounting for other covariates from the vehicle trajectory (e.g., speed).

* Estimate the optimal position for the vehicle on the matched road segment.
  

## Detect Driving Behavior from Large-Scale Spatiotemporal Transportation Data

For example,

* Develop driving biomarkers for age-related cognitive decline in senior citizens.

* Derive the time to complete turning maneuvers at intersections.

* Quantify the influence of work zones, crashes, etc. on traffic flow.

## References


