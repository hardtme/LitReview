---
title: "Statistical Tools for Large-Scale Spatio-Temporal Transportation Data"
subtitle: "Project Proposal"
date: "2025-10-20"
author: "Marie Hardt"
bibliography: "`r rbbt::bbt_write_bib('overviewreferences.bib', keys=rbbt::bbt_detect_citations(here::here('problem_overview.qmd')),
   ignore = stringr::str_subset(rbbt::bbt_detect_citations(here::here('problem_overview.qmd')), '(^fig-|^tbl-|^eq-|^sec-|^lst-|^thm-|^lem-|^cor-|^prp-|^cnj-|^def-|^exm-|^exr-)'), overwrite = TRUE, library_id='Graphics-Research', translator='bibtex')`"
number-sections: true
header-includes:
   - \usepackage{hyperref}
   - \usepackage[dvipsnames]{xcolor} % colors
   - \usepackage{longtable}
   - \newcommand{\mh}[1]{{\textcolor{teal}{#1}}}
   - \newcommand{\gb}[1]{{\textcolor{RedOrange}{#1}}}
   - \newcommand{\hh}[1]{{\textcolor{Green}{#1}}}

format:
  pdf:
    keep-tex: true
    fontsize: 11pt
    toc: true
    link-citations: true
    geometry:
      - right=1in
      - left=1in
      - top=1in
      - bottom=1in

filters:
   - latex-environment
commands: [mh,bg,hh] 
execute: 
  echo: false
abstract: |
  Driving is a spatio-temporal process essential to modern life. Advancements in data collection technologies allow the capture of telematics data from vehicles as they are driven. Such data include the vehicle's location (latitude/longitude, often from GPS), speed, heading, etc. These driving data are used in a wide variety of applications, including traffic flow analysis and cognitive health monitoring for older drivers. However, the vehicle location data are usually recorded with errors that cause the reported locations of a vehicle to not fall on the road system. These errors increase the challenges of working with such telematics data. An overview of GPS data collection and how position errors can arise and affect recorded locations is presented. The types of telematics data used in this research are discussed. Then, the map-matching problem (a way to correct GPS data errors by matching points to the road system) is introduced. Lastly, ideas for new statistical tools in the realm of large-scale spatio-temporal transportation data are proposed.
---

```{r setup}
#| echo: false
#| warning: false
#| message: false
library(rbbt)
library(tidyverse)
library(leaflet)
library(sf)
library(glue)
# remotes::install_github("hardtme/DrivePlotR)
library(DrivePlotR)
library(tmap)
tmap_mode("plot")
# remotes::install_github("dill/emoGG")
library(emoGG)
library(gpsdriving)
library(fontawesome)

fa_by_name <- function(name, fill = "blue", stroke = "white", stroke_width = "1px") {
  fa_png(
    name = name,
    fill = fill,
    fill_opacity = 1,
    stroke = stroke,
    stroke_width = stroke_width, 
    stroke_opacity = 1,
    height = 512,
    width = 512
  )
}

example_tmap <- function(basemap = "CartoDB.VoyagerNoLabels",
                         road_system,
                         bbox,
                         road_system_color = "tan",
                         road_system_lwd = 10,
                         og_points,
                         og_points_color = "blue",
                         new_points,
                         new_points_color = "red",
                         point_size = 1,
                         point_fill_alpha = 1,
                         match_lines,
                         match_lines_color = "black"){
ex_tmap <- tm_basemap(server = basemap)+
  tm_shape(road_system, bbox = bbox)+
  tm_lines(col = road_system_color, lwd = road_system_lwd)+
  tm_shape(match_lines, bbox = bbox)+
  tm_lines(col = match_lines_color)+
  tm_shape(og_points, bbox = bbox)+
  tm_dots(size = point_size, fill = og_points_color, fill_alpha = point_fill_alpha, 
          group = "original", group.control = "none")+
  tm_shape(new_points, bbox = bbox)+
  tm_dots(size = point_size, fill = new_points_color, fill_alpha = point_fill_alpha,
          group = "shifted", group.control = "none")
return(ex_tmap)
}
```

<!-- # To Dos -->


<!-- \mh{To do items for the data sources} -->

<!-- \mh{1. Find a good example that you can use to show the geospatial drift you mention and create code for a picture for both the NDS and the CV data.} -->

<!-- \mh{2. For the NDS data, shift the data manually (using a single delta x, delta y for a shift) to the right place, and save that as the ‘target’. Calculate the sum of squares between the before and after locations. That is going to be our error for that example and will serve as the baseline to measure progress.} -->

<!-- \mh{3. I am not completely sure what a GPS error will look like in the CV data. What I am hoping for is a time dependent GPS drift, when all of the measurements will shift by a delta x, delta y. If that is a case, we can proceed with creating an example in the same way as (2). If not, keep track of how the error is showing itself.} -->

<!-- \mh{4. (For Later) We will need a couple more of these training examples, but let’s focus on the documentation of the first two examples first.} -->

<!-- \mh{5. Try to quantify the error in GPS data more - not necessarily for the overview, but to document the need for an algorithm. This might be best done by a general discussion of how GPS quality is determined and a specific summary of how ‘good’ the GPS is in the NDS study and the connected vehicles} -->


# Introduction {#sec-introduction}

<!-- \hh{XXX The purpose of this first section is to motivate  your work by answering What? and Why?} -->

<!-- \hh{XXX What is at the heart of your work? Spatio-temporal processes. As human beings we are surrounded by spatio-temporal processes. With increasing technology a lot of these processes are being captured quantitatively, and we are relying on a lot of devices that make use of capturing these quantities. } -->

<!-- We increasingly rely on connected devices to improve the quality of our lives. For example, navigation apps in our smartphones make it easy to navigate to anywhere we need to go. Such smart devices provide a wealth of data about complex spatio-temporal processes. However, even the most sophisticated smart devices can fail and return obviously incorrect data, such as location data for driving trips that fall nowhere near a roadway. Such erroneous data must be cleaned and corrected before they can be used to develop insight in applications. We created new statistical methods to orthogonally project driving trip trajectories onto the road system. We also developed tools for working with and visualizing spatio-temporal telematics data such as driving trip trajectories.  -->

We live in a world filled with spatio-temporal processes. Consider the everyday activity of driving as an example. Advancements in data collection technology, such as in-vehicle instrumentation and smartphone apps, quantitatively capture telematics data from vehicles as they are driven. Such data include the vehicle's location, speed, and direction of travel, among other possibilities depending on the instrumentation used. Driving data have applications in many fields, including transportation, logistics, insurance, and health.

However, driving data collection devices can fail and return erroneous locations that do not match the vehicle's true locations. For example, recorded vehicle locations gathered from a trip through the streets of a city can fall nowhere near a roadway, although the vehicle spent the whole trip driving on public roads. Such erroneous data must be cleaned and corrected before they can be used in applications. For example, to accurately calculate the traffic volume on a road segment, the number of vehicles driving on the road segment must be known. Data points recorded as being off the roadway will not be included in the analysis, obscuring the true traffic volume. For applications examining driver behavior, such as naturalistic driving studies, it is difficult to gain a full understanding of driver behavior without knowing where on the road system the study participants actually drove.

Several key factors are needed before driving data can be utilized to their full potential. Analysts need to visualize driving trajectories so they can assess the quality of the location data and explore how variables other than location (e.g., speed) change over the course of the drive. These changes can then be related to the geospatial trajectory. Driving data may include position quality measures, but these measures may not give an accurate picture of the true reliability of the recorded locations. This makes trajectory visualization all the more crucial.

Errors in driving location data carry through to affect analyses done with the data. Thus, it is essential to project erroneously recorded driving location data onto the road system. The necessary level of the precision for the projection depends on the application. Some applications (such as route reconstruction) only require the knowledge of which road segment the vehicle used, while others depend on the precise location of the vehicle on the road segment. A huge variety of methods have been introduced to address this issue, with most methods heavily focused on selecting the road segment traversed by the vehicle at any recorded point. After the road segment used by the vehicle has been selected, the vehicle's location may then be shifted onto the segment.

<!-- \hh{XXX The following sentence is the answer to a How? question - it doesn't motivate.} -->
In pursuit of our goals to create new statistical tools to visualize, process, and analyze large-scale geospatial transportation data, we use two primary telematics data sources: naturalistic driving study (NDS) data and connected vehicle (CV) data. Both of these telematics data sources make extensive use of location information acquired from the Global Positioning System (GPS). 

The organization of this work is as follows. We first discuss some essential background regarding GPS data in @sec-crs, @sec-gps, and @sec-dop. @sec-physics explains the physics of motion based on location data from vehicles. We describe NDS data in @sec-nds and also describe CV data in @sec-cv. @sec-problemoverview provides an overview of the map-matching problem. Some map-matching algorithms and their drawbacks are discussed in @sec-MMalgos. Current solutions to the position determination problem in map-matching are provided in @sec-roadselection. A proposal for this work is found in @sec-proposal.

# Geolocation Data from the Global Positioning System 

## Coordinate Reference Systems {#sec-crs}

To work with location data, we must know the coordinate reference system for the data. @iliffeDatumsMapProjections2008 provided an overview of this topic. Coordinate reference systems arise from the positioning and orienting of a coordinate system with respect to a datum. For any coordinate system, the system dimension, or the number of axes for the system, must be defined. We also need to know the name of each axis, the order of the axes (which in turn gives the order of coordinates), the direction in which coordinates increase along the axes, and the measurement units for the axes. Coordinate systems for the approximately spherical (actually ellipsoidal) Earth use three axes: latitude (the angle north or south of the equatorial plane), longitude (the angle east or west from a specified prime meridian), and height (the distance above the surface of the Earth).

However, latitude and longitude coordinates are ambiguous without information about the datum used to relate the coordinate system to the Earth's surface. The Earth's true shape is called the geoid, and a geodetic datum relates an ellipsoidal approximation of the shape of the Earth to the geoid. A datum must be realized through physical monuments of established coordinates in the area of interest before it can be used. A coordinate reference system (CRS) is a coordinate system associated to an object through the use of a datum.

Since the geolocation data for this project come from the Global Positioning System (GPS), the primary CRS used in this project is the World Geodetic System of 1984, abbreviated WGS 84. WGS 84 is the CRS for GPS locations. The starting points for WGS 84 are the orbital positions transmitted by the GPS satellites and determined by a network of monitoring stations maintained by the United States military. The WGS 84 datum is realized by the coordinates of these monitoring stations.

@iliffeDatumsMapProjections2008 explained that map projections must be used to visualize locations from the three-dimensional surface of the Earth on a two-dimensional map. However, spheres and ellipsoids cannot be projected onto a flat surface like a map without distorting or cutting them. Such distortion should not be considered an error, however, because the method of projection is known and the true coordinates in the original, unprojected CRS may be obtained if the projection parameters are known. For example, interactive maps created with the R package `leaflet` expect that the input coordinates use the WGS 84 CRS [@chengLeafletCreateInteractive2024]. Plotting functions in the `leaflet` package then use the WGS 84 Web Mercator projection to project the coordinates onto a two-dimensional map.

## Global Positioning System (GPS) Overview {#sec-gps}

@iliffeDatumsMapProjections2008 summarized the essential features of GPS. It is part of the Global Navigation Satellite System (GNSS), which provides accurate location and navigation information. Any GNSS (including GPS) involves a constellation of satellites orbiting the Earth in a specified pattern. Typically, 6 to 10 of the satellites in the constellation are above the horizon at any time, but not all of the satellites may be usable by the receiver due to obstructions like tall buildings. A ground-based network of monitoring and control stations continually determines the orbital paths of the satellites in the constellation. The ground stations make short-term predictions of the satellites' locations in orbit and transmit these predictions back to the satellites. The satellites then relay their positions to receivers. @fig-gps shows simplified depictions of signals being transmitted from GPS satellites in orbit to a receiver in a vehicle on the ground. GPS satellite constellation geometry is discussed further in @sec-dop. 

```{r}
#| echo: false
#| layout: [[45,-10, 45]]
#| fig-cap: "Examples of GPS satellite constellation geometries."
#| fig-subcap: 
#|  - "Poor satellite geometry."
#|  - "Good satellite geometry."
#| label: fig-gps

receiver <- data.frame( x = 0, y = 0)

bad_satellites <- data.frame(x = c(-0.7, -0.3, -0.5, -0.8),
                             y = c(7.5, 9.75, 9, 6.5))

good_satellites <- data.frame(x = c(1, -1, -0.3, 0.4),
                         y = c(7, 8, 10, 9.5))

bad_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = bad_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = bad_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
bad_sats

good_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_hline(yintercept = -0.4, linewidth = 4, color = "gray30")+
  geom_emoji(data = good_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = good_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(-0.5, 10.5), expand = expansion(mult = c(0, 0), add = c(0, 0)))
good_sats

```

GPS satellites send information to receivers by modulating the information onto a set of underlying carrier waves of specified frequencies. In addition to satellite location information and general system information, each satellite also transmits a pre-determined sequence of binary codes at particular times. These codes can be thought of as time information if the user can receive them. To aid the process in the case of weak signals, the GPS receiver already stores a copy of the code to give it an idea of what to expect. The GPS receiver generates the code itself and then finds the time offset between its own code and the code it receives from the satellite, thus finding the signal's travel time.

The distance from the GPS receiver to the satellite can be calculated by multiplying the signal's travel time by the signal's transmission speed (i.e., the speed of light). Theoretically, it should be possible to determine the GPS receiver's location based on observations from three satellites and solving a simultaneous system of three equations in three unknowns (say $X$, $Y$, $Z$). However, there is a problem with this method because the satellite clock and the receiver clock are not synchronized with each other. GPS satellites use very precise atomic clocks that are continuously monitored by the ground stations, but receivers must make do with much cheaper, less accurate clocks. Since light travels approximately 300,000 km/s, an offset of 1 second between the satellite clock and the receiver clock will lead to a 300,000 km error in the distance calculation. To solve the problem, a fourth satellite is needed. Then the offset between the satellite times and the receiver time can be included in a simultaneous system of four equations in four unknowns (say $X$, $Y$, $Z$, $\Delta t$).

## Dilution of Precision {#sec-dop}

Even when four or more satellites are visible to the GPS receiver, GPS location measurements are not immune to errors. @isikIntegrityAnalysisGPSBased2020 explained that errors may arise from a variety of sources, including satellite errors, transmission errors, environmental errors, and receiver errors. Such errors are why the GPS position fixes recorded by instrumentation in moving vehicles do not always fall on the road system.

Dilution of Precision (DOP) coefficients are unitless measurements representing the relative positions of navigation satellites and the receiver and the influence of the relative positions on the location obtained. There are multiple types of DOP coefficients, each accounting for a different location aspect. Three DOP types were available in the NDS data we used: Position DOP (PDOP), Horizontal DOP (HDOP), and Vertical DOP (VDOP).

The DOP coefficients available in the NDS data used in this study have the following relationship, as described by @isikIntegrityAnalysisGPSBased2020:

$$
\begin{aligned}
\text{PDOP} &= \sqrt{\text{HDOP}^2 + \text{VDOP}^2}.\\
\end{aligned}
$$

@isikIntegrityAnalysisGPSBased2020 also showed how to calculate the DOP coefficients. Let $\theta_1$, $\theta_2$, $\theta_3$, and $\theta_4$ denote the elevations above the receiver's horizon of the four best satellites for calculating DOP coefficients. Also let $\varphi_1$, $\varphi_2$, $\varphi_3$, and $\varphi_4$ denote the azimuths (i.e., the direction away from the receiver) of the four best satellites. Then we have

$$
\begin{aligned}
G &= \begin{bmatrix}
-\cos(\theta_1)\sin(\varphi_1) & -\cos(\theta_1)\cos(\varphi_1) & -\sin(\theta_1) & 1\\
-\cos(\theta_2)\sin(\varphi_2) & -\cos(\theta_2)\cos(\varphi_2) & -\sin(\theta_2) & 1\\
-\cos(\theta_3)\sin(\varphi_3) & -\cos(\theta_3)\cos(\varphi_3) & -\sin(\theta_3) & 1\\
-\cos(\theta_4)\sin(\varphi_4) & -\cos(\theta_4)\cos(\varphi_4) & -\sin(\theta_4) & 1\\
\end{bmatrix},\\
H &= \left(G^T \cdot G\right)^{-1},\\
\text{PDOP} &= \sqrt{H_{11} H_{22} H_{33}},\\
\text{HDOP} &= \sqrt{H_{11} H_{22}},\\
\text{VDOP} &= \sqrt{H_{33}}.
\end{aligned}
$$

Higher DOP coefficients indicate worse positional accuracy. Two main factors increase DOP coefficients: sub-optimal geometry of the satellite constellation and obscured satellites. Even under ideal conditions, the geometry of the satellite constellation visible to the receiver constantly changes due to the movement of the satellites and the receiver. For DOP calculations, four satellites that are further apart in the sky (as visible from the receiver) are more optimal than four satellites that are close together in the sky, as shown in @fig-gps. Satellite obscuration prevents some satellites from being visible to the receiver. Tall buildings in urban areas commonly obscure satellites, which is a problem because the receiver cannot see more optimal satellites and must instead rely on a suboptimal satellite constellation to determine location. This can cause significant errors in GPS locations reported from vehicles traveling in urban areas.

@isikIntegrityAnalysisGPSBased2020 noted that there is no agreed-upon standard for relating DOP coefficient values to the quality of navigation data. They presented the scale for DOP coefficient values shown in @tbl-dop based on the literature and the results of their own work. Recall that lower DOP coefficient values should indicate higher quality navigation data. 

:::{#tbl-dop}

```{=latex}
\begin{table}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
DOP Value             & $<1$  & $1-2$     & $2-5$ & $5-10$   & $10-20$ & $>20$ \\ \hline
Location Data Quality & Ideal & Excellent & Good  & Moderate & Fair    & Poor  \\ \hline
\end{tabular}
\end{table}
```

Scale relating the value of dilution of precision (DOP) coefficients to location data quality [@isikIntegrityAnalysisGPSBased2020].
:::

## Physics of Motion {#sec-physics}

We now present the physics of motion in the context of GPS points recorded from moving vehicles. For simplicity, the equations presented will use Cartesian coordinates instead of a projected coordinate system like those discussed in @sec-crs. Over small distances, such as those between consecutive GPS locations with a high sampling rate, the differences between the two types of coordinate systems become negligible.

Suppose that for a given driving trip, we have recorded the vehicle's location (longitude and latitude) at a finite number of time points $t$, $t = 0, 1, ..., T$. In practice, the time difference between consecutive observations is not necessarily one second, nor is the time interval between consecutive observations necessarily consistent throughout the drive. Consider two consecutive observed vehicle positions $\symbfit{r}_t$ and $\symbfit{r}_{t+\Delta t}$. Then the average velocity of the vehicle between the two positions is given in @eq-avgvelocity:
$$
\symbfit{v}_{\text{avg}} = \frac{\symbfit{r}_{t+\Delta t} - \symbfit{r}_t}{(t + \Delta t) - t} = \frac{\Delta \symbfit{r}}{\Delta t}.
$$ {#eq-avgvelocity}
That is, average velocity is the change in position divided by the change in time.

As the difference in time, $\Delta t$, between consecutive location observations goes to 0, we can use the limit of the average velocity to find the instantaneous velocity of the vehicle. In other words, instantaneous velocity is the first derivative of position with respect to time. Instantaneous position is given in @eq-instvelocity:
$$
\symbfit{v}_{\text{inst}} = \lim_{\Delta t \rightarrow 0} \frac{\Delta \symbfit{r}}{\Delta t}  = \frac{d\symbfit{r}}{dt}.
$$ {#eq-instvelocity}

Now consider the average acceleration (rate of change for velocity) of the vehicle between two consecutive observed vehicle positions $\symbfit{r}_t$ and $\symbfit{r}_{t+\Delta t}$. This is given in @eq-avgaccel:
$$
\symbfit{a}_{\text{avg}} = \frac{\symbfit{v}_{t + \delta t} - \symbfit{v}_t}{(t + \Delta t) - t} = \frac{\Delta \symbfit{v}}{\Delta t}.
$$ {#eq-avgaccel}

Instantaneous acceleration is defined in a very similar way to instantaneous velocity, as shown in @eq-instaccel:
$$
\symbfit{a}_{\text{inst}} = \lim_{\Delta t \rightarrow 0} \frac{\Delta \symbfit{v}}{\Delta t} = \frac{d\symbfit{v}}{dt} = \frac{d^2 \symbfit{r}}{dt^2}.
$$ {#eq-instaccel}
Hence, we can see that instantaneous acceleration is the first derivative of velocity with respect to time and the second derivative of position with respect to time.

Acceleration depends on velocity, which in turn depends on position. Thus, errors in GPS position fixes propagate through to negatively impact GPS-derived velocity and acceleration measures as well. A common issue with GPS locations for vehicles is that position and heading fixes are highly prone to error when the vehicle is stationary or moving slowly [@kubickaDatasetTestingTraining2015]. Position fix issues can still occur even when the vehicle is moving at speed. Recall from @sec-dop that such issues may be due to satellite errors, transmission errors, environmental errors, or receiver errors. Thus, it is important to become familiar with the sources of GPS vehicle trajectory data and the expected magnitude of the position errors within the data.

# Driving Data Sources {#sec-drivingdatasources}

## Naturalistic Driving Study Data {#sec-nds}

Naturalistic driving studies are a source of multivariate high resolution spatio-temporal driving data. Participants in a naturalistic driving study (NDS) consent to have a data acquisition system (DAS) installed in their vehicles during the study period so their driving behaviors can be monitored and recorded. A notable example of an NDS is the one administered by the Transportation
Research Board of the National Academies as part of the
Second Strategic Highway Research Program (SHRP 2), which aimed to understand how driver performance and behavior impact traffic safety. For the SHRP 2 NDS, study participants from
six different US states consented to have their driving monitored by an in-vehicle DAS equipped with various data collection channels, including video cameras, a global positioning system (GPS) unit, and accelerometers, among others [@campbellSHRP2Naturalistic2012]. The Longitudinal Research on Aging Drivers (LongROAD) study was a more recent NDS that focused on collecting data from participants aged 65 to 79 to better understand how medical, behavioral, environmental, and technological factors influence road safety as drivers age [@liLongitudinalResearchAging2017].

This project utilized data from an NDS conducted by the University of Nebraska Medical Center (UNMC) The study was supported by the National Institutes of Health (NIH), the National Institute on Aging (NIA 5R01AG17177-18), and the University of Nebraska Medical Center Mind \& Brain Health Labs. This NDS aimed to use driving data from older drivers to develop biomarkers for early detection and monitoring of cognitive decline. The variables available in the processed UNMC NDS data are described (as per the internal study documentation) in @tbl-rwrad. The most essential variables in the dataset are the latitude/longitude, timestamp, speed, heading, and the DOP measures. Observations are given at a sampling frequency of 1 Hz, i.e., one observation every second.

<!-- From the file BlackBox_FormatQAPass_DataDictionary.docx -->

## Connected Vehicle Data {#sec-cv}

The CV data come from the data provider StreetLight and are available from the Institute for Transportation (InTrans) at Iowa State University. The connected vehicles directly provide trajectory information every 1-3 seconds throughout their journeys. (Samples are usually recorded every three seconds.) Each trip is uniquely identified by a unique JourneyID and each data point has a unique DatapointID (InTrans internal documentation, 2025).

Connected vehicles collect a variety of data throughout their journeys, including vehicle location, speed, and heading. Other variables, such as acceleration, are derived from the data. @tbl-cvmetadata provides an overview of the available variables in the CV data, as described in the InTrans internal documentation. Similar to the NDS data, the most essential variables are the latitude/longitude, timestamp, speed, and heading. Unlike the NDS data, no measures of GPS quality are directly provided in the CV data.

## Road Network Metadata {#sec-roadnetwork}

As described in the InTrans internal documentation, the CV data continuously stream into InTrans, which listens and archives data approximately every 60 seconds. The data are processed as they are archived, and part of the process involves relating the CV data to the Iowa DOT road network, as provided by the Road Asset Management System (RAMS). The road network is broken into approximately 0.1 mile segments for relating to the CV data. The CV data points are associated to the closest roadway, and the priority of a roadway for association to the CV is determined by the roadway's facility type. The process for doing this is described in more detail in @sec-MMalgos. Knowing the nearest road to each connected vehicle point is helpful in applications. For example, if a crash is known to have occurred near a particular mile marker on a road, it is simpler to filter the CV data records by road and mile marker to assess the effect of the crash on traffic flow. @tbl-roadnetwork provides names and descriptions of the fields resulting from the matching of the CV data to the road system. The descriptions of these variables are based on the InTrans internal documentation.

## Similarities Between Data from Naturalistic Driving Studies and Connected Vehicles {#sec-similarities}

NDS and CV data are very similar to each other. Both data sources provide observations from vehicle trips, including the vehicle location (latitude and longitude), speed, and heading. These data are reported frequently, usually every one to three seconds. Depending on the nature of the data acquisition systems installed in the study participants' vehicles, NDS data may include additional information that CV data do not provide, such as the DOP coefficients associated with the GPS data. However, NDS data and CV data contain the same fundamental information (location, speed, and direction of travel for the vehicle). It is also possible to acquire similar trajectory data from micromobility solutions like bicycles and scooters. 

# Map-Matching Problem {#sec-MM}

## Overview {#sec-problemoverview}

As we have worked with driving data, particularly the NDS data from the UNMC study, we have noticed that GPS location data can drift away from the road system, even when the DOP coefficients for the data points fall within the Excellent to Good ranges from the scale in @tbl-dop. The blue points in @fig-gps-drift are the original points returned by the GPS unit installed in a vehicle used in a NDS, and the PDOP values for these points range from 1.63 to 2.36. Despite their low PDOP values, these points do not fall on the road system and thus are not high quality GPS location data. This situation also illustrates the need for analysts to explore and visualize driving trajectory data before performing any analyses. GPS errors like these make geospatial analysis of the data much more challenging. 

The map-matching problem arises from the need to associate recorded locations of a moving vehicle to a finite road system represented as $\mathcal{R}$. We have recorded observations of the vehicle's location at a finite number of time points $t$, $t = 0, 1, ..., T$. Let $\symbfit{p}_t$ denote the vehicle's true location (given in latitude and longitude with a known CRS) at time $t$. Due to error in the position fix, $\symbfit{p}_t$ is unknown. Let $\symbfit{p}^*_t$ denote the vehicle's recorded location at time $t$, which may not fall on the road system, $\mathcal{R}$, due to position error. The goal of a map-matching algorithm is to use $\symbfit{p}^*_t$ to determine the road $R_t$ in $\mathcal{R}$ where the true vehicle location, $\symbfit{p}_t$, was found. After determining $R_t$, it may also be of interest to provide an estimate $\widehat{\symbfit{p}}_t$ of $\symbfit{p}_t$ based on $\symbfit{p}^*_t$ and located on $R_t$.

Thus, map-matching algorithms seek to solve two fundamental problems: 

1. On which road is the vehicle driving? (Road selection problem)

2. Where on the road is the vehicle driving? (Position determination problem)

The map-matching question of more focus depends on the intended application for the algorithm. For example, to determine traffic volume for a particular road segment, it is sufficient to know how many vehicles traveled on the road segment. In this case, the exact locations of the vehicles on the road segment are unimportant. For other applications, the precise locations of vehicles on the road segment are important. Consider the case where we want to know whether drivers are stopping behind the stop bar at a stop-controlled intersection. Highly precise vehicle locations are needed to compare with the stop bar location.

Regardless of the intended application, all map-matching algorithms require a geospatial representation of the road system where the vehicle trajectories in question may be assumed to have occurred. For NDS and CV driving data, it is reasonable to expect the vast majority of driving will take place on public roads. The scale and quality of the road system representation used in the map-matching process affects the potential accuracy of corrected vehicle trajectories that may be achieved.

```{r}
#| echo: false
#| eval: false
#| label: fig-gps-drift-leaflet
#| fig-caption: |
#|   Example of GPS drift and manual shifting from original points (blue) to points more in line with the road (red)  

data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

exdrive <- nds_data_sf |>
  filter(drive == 23)

# We need to shift the longitude and latitude values.
#offset <- st_as_sfc("POINT(0.000065 -0.000065)", crs = "WGS84")
#offset <- st_as_sfc("POINT(0.000075 -0.000073)", crs = "WGS84")
offset <- st_as_sfc("POINT(0.00015 0.000055)", crs = "WGS84")

shifted_points <- exdrive |>
  mutate(geometry = geometry + offset)

exdrive_plot <- exdrive |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shifted_points_plot <- shifted_points |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shift1 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.PositronNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = exdrive_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot, color = "red", label = ~glue("{time_utc}"))

offset2 <- st_as_sfc("POINT(0 -0.00008)", crs = "WGS84")

before_turn <- shifted_points_plot |>
  filter(time_utc <= ymd_hms("2019-05-28 21:17:24")) |>
  mutate(geometry = geometry + offset2)

after_turn <- shifted_points_plot |>
  filter(time_utc > ymd_hms("2019-05-28 21:17:24"))

shifted_points_plot2 <- rbind(before_turn, after_turn)

shift2 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.PositronNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = exdrive_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot2, color = "red")

offset3 <- st_as_sfc("POINT(0 -0.000046)", crs = "WGS84")

before_turn2 <- shifted_points_plot2 |>
  filter(time_utc <= ymd_hms("2019-05-28 21:17:23")) |>
  mutate(geometry = geometry + offset3)

after_turn2 <- shifted_points_plot2 |>
  filter(time_utc > ymd_hms("2019-05-28 21:17:23"))

shifted_points_plot3 <- rbind(before_turn2, after_turn2)

shift3 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.VoyagerNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = exdrive_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot3, color = "red")

#shift3
```

```{r}
#| echo: false
#| eval: false
#| label: fig-gps-drift-old 
#| fig-caption: |
#|  Example of GPS drift and manual shifting from original points (blue) to points more in line with the road (red) 
data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

exdrive <- nds_data_sf |>
  filter(drive == 23)

# We need to shift the longitude and latitude values.
#offset <- st_as_sfc("POINT(0.000065 -0.000065)", crs = "WGS84")
offset <- st_as_sfc("POINT(0.000075 -0.000073)", crs = "WGS84")

shifted_points <- exdrive |>
  mutate(geometry = geometry + offset) |>
  st_set_crs("WGS84")

exdrive_plot <- exdrive |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shifted_points_plot <- shifted_points |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

# Get the lines between the original points and the matched points
all_points <- bind_rows(exdrive_plot, shifted_points_plot)
all_points_ls <- all_points |>
  group_by(time_utc) |>
  summarize() |>
  st_cast("LINESTRING")

exdrive_bbox <- st_bbox(exdrive_plot)

exdrive_bbox_adj <- exdrive_bbox
exdrive_bbox_adj[1] <- exdrive_bbox_adj[1] - 0.0001
exdrive_bbox_adj[2] <- exdrive_bbox_adj[2] - 0.0001
exdrive_bbox_adj[3] <- exdrive_bbox_adj[3] + 0.0001
exdrive_bbox_adj[4] <- exdrive_bbox_adj[4] + 0.0001

# USGS data
data("oma_roads")
# Make exdrive example bounding box into sf object
exdrive_bbox_sf <- exdrive_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the exdrive example above
poss_matches <- oma_roads |>
  st_filter(exdrive_bbox_sf, .predicate = st_intersects)

# gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#   tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "tan", lwd = 10)+
#   tm_shape(all_points_ls, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "black")+
#   tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "blue", group = "original", group.control = "none")+
#   tm_shape(shifted_points_plot, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "red", group = "shifted", group.control = "none")
# 
# gps_drift_tmap

gps_drift_tmap <- example_tmap(road_system = poss_matches,
                               bbox = exdrive_bbox_adj,
                               og_points = exdrive_plot,
                               new_points = shifted_points_plot,
                               match_lines = all_points_ls)
gps_drift_tmap
```

:::{#fig-gps-drift}

```{r}
#| echo: false
#| eval: true

data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

exdrive <- nds_data_sf |>
  filter(drive == 23)

exdrive_plot <- exdrive |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

exdrive_plot <- exdrive_plot |>
  mutate(pt_label = c("Start", rep("", 8), "End"))

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = exdrive_plot, label = ~glue("{round(speed_mph, 2)} mph"))

# offset_pt1 <- st_as_sfc("POINT(0.00018 -0.000075)", crs = "WGS84")
# pt1 <- exdrive_plot[1,]
# shifted_pt1 <- pt1 |>
#   mutate(geometry = geometry + offset_pt1)

# Use the same offset as point 1 for point 2
# pt2 <- exdrive_plot[2,]
# shifted_pt2 <- pt2 |>
#   mutate(geometry = geometry + offset_pt1)

# offset_pt3 <- st_as_sfc("POINT(0.00018 -0.000073)", crs = "WGS84")
# pt3 <- exdrive_plot[3,]
# shifted_pt3 <- pt3 |>
#   mutate(geometry = geometry + offset_pt3)

# offset_pt4 <- st_as_sfc("POINT(0.00018 -0.00007)", crs = "WGS84")
# pt4 <- exdrive_plot[4,]
# shifted_pt4 <- pt4 |>
#   mutate(geometry = geometry + offset_pt4)

# offset_pt5 <- st_as_sfc("POINT(0.00016 -0.00003)", crs = "WGS84")
# pt5 <- exdrive_plot[5,]
# shifted_pt5 <- pt5 |>
#   mutate(geometry = geometry + offset_pt5)

# offset_pt6 <- st_as_sfc("POINT(0.00015 0.00005)", crs = "WGS84")
# pt6 <- exdrive_plot[6,]
# shifted_pt6 <- pt6 |>
#   mutate(geometry = geometry + offset_pt6)

# Use the same shift for point 7
# pt7 <- exdrive_plot[7,]
# shifted_pt7 <- pt7 |>
#   mutate(geometry = geometry + offset_pt6)

# offset_pt8 <- st_as_sfc("POINT(0.000145 0.00005)", crs = "WGS84")
# pt8 <- exdrive_plot[8,]
# shifted_pt8 <- pt8 |>
#   mutate(geometry = geometry + offset_pt8)

# Use the same shift for point 9
# pt9 <- exdrive_plot[9,]
# shifted_pt9 <- pt9 |>
#   mutate(geometry = geometry + offset_pt8)

# offset_pt10 <- st_as_sfc("POINT(0.00014 0.00005)", crs = "WGS84")
# pt10 <- exdrive_plot[10,]
# shifted_pt10 <- pt10 |>
#   mutate(geometry = geometry + offset_pt10)

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = exdrive_plot, label = ~glue("{round(speed_mph, 2)} mph")) |>
#   addCircleMarkers(data = shifted_pt1, color = "brown") |>
#   addCircleMarkers(data = shifted_pt2, color = "black") |>
#   addCircleMarkers(data = shifted_pt3, color = "darkgray") |>
#   addCircleMarkers(data = shifted_pt4, color = "darkorchid") |>
#   addCircleMarkers(data = shifted_pt5, color = "magenta") |>
#   addCircleMarkers(data = shifted_pt6, color = "red") |>
#   addCircleMarkers(data = shifted_pt7, color = "orange") |>
#   addCircleMarkers(data = shifted_pt8, color = "gold") |>
#   addCircleMarkers(data = shifted_pt9, color = "green") |>
#   addCircleMarkers(data = shifted_pt10, color = "turquoise")

# manual_shift_points <- bind_rows(shifted_pt1, shifted_pt2,
#                                  shifted_pt3, shifted_pt4,
#                                  shifted_pt5, shifted_pt6,
#                                  shifted_pt7, shifted_pt8,
#                                  shifted_pt9, shifted_pt10)
# 
# manual_shift_points <- manual_shift_points |>
#   st_set_crs("WGS84")

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = exdrive_plot, color = "blue") |>
#   addCircleMarkers(data = manual_shift_points, color = "red")

# all_shifted_points <- bind_rows(exdrive_plot, manual_shift_points)
# all_shifted_points_ls <- all_shifted_points |>
#   group_by(time_utc) |>
#   summarize() |>
#   st_cast("LINESTRING")

exdrive_bbox <- st_bbox(exdrive_plot)

exdrive_bbox_adj <- exdrive_bbox
exdrive_bbox_adj[1] <- exdrive_bbox_adj[1] - 0.0002
exdrive_bbox_adj[2] <- exdrive_bbox_adj[2] - 0.0002
exdrive_bbox_adj[3] <- exdrive_bbox_adj[3] + 0.0002
exdrive_bbox_adj[4] <- exdrive_bbox_adj[4] + 0.0002

# USGS data
data("oma_roads")
# Make exdrive example bounding box into sf object
exdrive_bbox_sf <- exdrive_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the exdrive example above
poss_matches <- oma_roads |>
  st_filter(exdrive_bbox_sf, .predicate = st_intersects)

# gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#   tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "tan", lwd = 10)+
#   tm_shape(all_shifted_points_ls, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "black")+
#   tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
#   tm_labels(text = "pt_label", xmod = 1.5, options = opt_tm_labels(point.label = FALSE))+
#   tm_shape(manual_shift_points, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "red", group = "shifted", group.control = "none", fill_alpha = 0.9)
# 
# gps_drift_tmap

# gps_drift_tmap <- example_tmap(road_system = poss_matches,
#                                bbox = exdrive_bbox_adj,
#                                og_points = exdrive_plot,
#                                new_points = manual_shift_points,
#                                match_lines = all_shifted_points_ls,
#                                point_fill_alpha = 0.9)

gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels") +
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10)+
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "blue", fill_alpha = 0.9, 
          group = "original", group.control = "none")

gps_drift_tmap <- gps_drift_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.5, options = opt_tm_labels(point.label = FALSE))

gps_drift_tmap
```
Example of drift in recorded GPS locations for a moving vehicle. 
:::

## Brief Overview of Map-Matching Algorithms and Related Issues {#sec-MMalgos}

The map-matching problem has attracted a great deal of attention since GPS was made available for civilian applications in the early 1990s. Hundreds of different map-matching algorithms and algorithm improvements have been introduced since then. These map-matching methods range from intuitive and simple to computationally complex and highly accurate. Map-matching methods can be used online or offline. Online methods run as the vehicle is driven and the data points are collected. Hence, they must have fast computation times to perform map-matching in near real-time. Conversely, offline map-matching methods are used after the complete vehicle trajectory is available. More complex calculations and longer computation times are possible. Several surveys of the map-matching literature have been conducted over the years; see, for example, @quddusCurrentMapmatchingAlgorithms2007, @weiMapMatchingComparison2013, @kubickaComparativeStudyApplicationOriented2018, @chaoSurveyMapMatchingAlgorithms2020, @sakiPracticalGuideOpenSource2022, and @guptaComprehensiveReviewMapMatching2022. Only a small subset of all map-matching methods will be discussed here.

The simplest way to solve the road selection problem is to find the road segment closest to the recorded location of the vehicle. @bernsteinIntroductionMapMatching1996 used point-to-point map-matching to find the "node" (road segment endpoint) or "shape point" (point on the road segment between the endpoints) closest to the recorded vehicle location according to Euclidean distance. They also utilized a point-to-curve map-matching approach that found the closest curve in the road system to the recorded vehicle location. @whiteMapMatchingAlgorithms2000 also explored a point-to-curve map-matching approach.

@bernsteinIntroductionMapMatching1996 and @whiteMapMatchingAlgorithms2000 investigated curve-to-curve matching approaches. Under a curve-to-curve matching approach, candidate matches are first identified using point-to-point map-matching, and then piecewise-linear curves are created based on possible routes starting from these candidates. Additional piecewise-linear curves are created based on the sequence of points in the vehicle's trajectory. The candidate curve closest to the vehicle trajectory curve is chosen as the road used by the vehicle. @taylorRoadReductionFiltering2001 used White et al.'s curve-to-curve map-matching method as the starting point for their road reduction filter map-matching algorithm. However, @quddusCurrentMapmatchingAlgorithms2007 noted several drawbacks associated with such geometric map-matching approaches, including sensitivity to outliers, instability of results in dense urban networks with many roads in close proximity, and the fact that the closest road may not be the correct road.

Despite the known issues with geometric map-matching methods and the later appearance of alternative methods (to be discussed later), this type of strategy is still used in applications. For example, InTrans uses a nearest-road method to associate CV data points to the closest roadway. However, the priority of a roadway for association to the CV data points is determined by the roadway's facility type. This means that, for example, a point is more likely to be matched to a nearby interstate highway than a nearby local road. The position determination problem is subsequently solved by orthogonally projecting the recorded vehicle location onto the selected road segment.

@fig-naive-map-matching shows an example of a case where the closest road identified by a geometric map-matching method is not the correct road. The example uses the same data as @fig-gps-drift. Once again, the original points are blue. The matched points are red. The orthogonal projections onto the road system looks good for six of the ten points, but the four points west of the intersection (near the yellow warning symbol) are problematic. The original points may be closer to the east-west road segment instead of the north-south road segment, but the matches do not fit with the rest of the vehicle trajectory. A more sophisticated map-matching method is needed.

<!-- Another matching method used by several authors (including @krakiwskyKalmanFilterIntegrating1988 and @scottIncreasedAccuracyMotor1994) and discussed by @sakiPracticalGuideOpenSource2022 is to fit a curve through a sequence of GPS points and find the road segments that best match the curve. Saki et al. observed that this curve-fitting approach worked well in some special cases, but performed poorly in most real-world applications. If heading information is available for the vehicle and the road system, it can be used to check the quality of matches, as Saki et al. noted was done by @bernsteinIntroductionMapMatching1996 and @whiteMapMatchingAlgorithms2000. -->

<!-- Saki et al. observed that @yangImprovedMapmatchingAlgorithm2003 and @quddusGeneralMapMatching2003 used Kalman filters to drop unreasonable GPS points and achieve better map-matching results. -->

:::{#fig-naive-map-matching}

```{r}
#| echo: false

# leaflet() |>
#   addProviderTiles(provider = "CartoDB.Positron") |>
#   addCircleMarkers(data = exdrive_plot, color = "black") |>
#   addPolygons(data = exdrive_bbox_sf) |>
#   addPolylines(data = poss_matches, color = "red")
# The road candidates are what we would expect.

# For each GPS point, find the nearest point on each of the road segments
nearest_pts_ls <- st_nearest_points(exdrive_plot, poss_matches)

nearest_pts_ls_sf <- st_as_sf(nearest_pts_ls)

# Find the distance between the original point and the matched point
nearest_pts_ls_sf <- nearest_pts_ls_sf |>
  rename(geometry = x) |>
  mutate(dist = st_length(geometry))

nearest_pts_ls_sf_start <- lwgeom::st_startpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_ls_sf_end <- lwgeom::st_endpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

# For each starting point, find the closest matched point
nearest_pts_end_match <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id) |>
  filter(dist == min(dist))

# Get the lines between the original points and the matched points
nearest_pts_ls_match <- nearest_pts_ls_sf |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches))) |>
  group_by(id) |>
  filter(dist == min(dist))

# leaflet() |>
#   addProviderTiles(provider = "CartoDB.VoyagerNoLabels") |>
#   addPolylines(data = nearest_pts_ls_sf, color = "blue") |>
#   addCircleMarkers(data = nearest_pts_ls_sf_start, color = "green") |>
#   addCircleMarkers(data = nearest_pts_ls_sf_end, color = "orange")

# mm_process_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#      tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#      tm_lines(col = "tan", lwd = 10)+
#      tm_shape(nearest_pts_ls_sf, bbox = exdrive_bbox_adj) +
#      tm_lines(col = "black")+
#      tm_shape(nearest_pts_ls_sf_start, bbox = exdrive_bbox_adj)+
#      tm_dots(size = 1, fill = "blue", group = "original", group.control = "none")
     
# leaflet() |>
#   addProviderTiles(provider = "CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = nearest_pts_start, color = "blue") |>
#   addCircleMarkers(data = nearest_pts_end_match, color = "red")

# mm_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#   tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "tan", lwd = 10) +
#   tm_shape(nearest_pts_ls_match, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "black")+
#   tm_shape(nearest_pts_ls_sf_start, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
#   tm_shape(nearest_pts_end_match, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)
# 
# mm_tmap 

#fa_by_name("triangle-exclamation", fill = "gold", stroke = "black")
fa_by_name("circle-exclamation", fill = "gold", stroke = "black", stroke_width = "5px")

warn_pt <- st_sfc(st_point(x = c(-95.99816, 41.25787)), crs = 4326) |>
  st_as_sf() |>
  st_cast("POINT")

#warn_pt_icon <- tmap_icons("triangle-exclamation.png")
warn_pt_icon <- tmap_icons("circle-exclamation.png")

mm_tmap <- example_tmap(road_system = poss_matches,
                               bbox = exdrive_bbox_adj,
                               og_points = exdrive_plot,
                               new_points = nearest_pts_end_match,
                               match_lines = nearest_pts_ls_match,
                        point_fill_alpha = 0.9)

mm_tmap <- mm_tmap +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(warn_pt, bbox = exdrive_bbox_adj) +
  tm_dots(size = 0.7, col = "black", fill_alpha = 1)+
  tm_symbols(shape = warn_pt_icon, size = 0.4)

mm_tmap
```
Example of the shortcomings of a geometric map-matching method where the closest road is not the correct road. The original GPS points (blue) were orthogonally projected onto the nearest road segment (red points). The yellow warning symbol west of the intersection draws attention to four nonsensically matched red points.
:::

<!-- :::{#fig-mmcircarrows} -->

```{r}
#| warning: false
#| message: false
#| include: false
# Get caret icons
fa_by_name("circle-chevron-up")
fa_by_name("circle-chevron-left")
fa_by_name("circle-chevron-down")
fa_by_name("circle-chevron-right")

up_ca <- tmap_icons("circle-chevron-up.png")
left_ca <- tmap_icons("circle-chevron-left.png")
down_ca <- tmap_icons("circle-chevron-down.png")
right_ca <- tmap_icons("circle-chevron-right.png")

mm_tmap_circle_arrows <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_match, bbox = exdrive_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(exdrive_plot #|> mutate(
    #gyro_heading = 360 - gyro_heading + 90) # use compass rose instead of unit circle representation
  ) + 
  tm_dots(size = 1, fill = "white", group = "original", group.control = "none", fill_alpha = 1)+ 
  tm_symbols(shape = "gyro_heading", size = 0.33, 
             shape.scale = tm_scale_intervals(
               style = "fixed",
               n = 5,
               #values = list(right, up, left, down, right),
               values = list(up_ca, right_ca, down_ca, left_ca, up_ca),
               breaks = c(0, 45, 135, 225, 315, 360)),
             group = "original", group.control = "none", 
             shape.legend = tm_legend(title = "Vehicle Heading\n(0 Degrees = North)")) +
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(nearest_pts_end_match, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_circle_arrows 
```
<!-- Example of the shortcomings of naively orthogonally projecting GPS points (blue with white arrows indicating vehicle heading) onto the nearest road segment (red). Note the four nonsensically matched red points west of the intersection. -->
<!-- ::: -->

```{r}
#| include: false
# Find the distance between consecutive matched points
# Create new dataset that is shifted by 1 index
nearest_pts_end_match_shift <- nearest_pts_end_match[-1,]
# Repeat the last point so st_distance doesn't throw an error
nearest_pts_end_match_shift <- rbind(nearest_pts_end_match_shift, nearest_pts_end_match_shift[nrow(nearest_pts_end_match_shift),])

match_consec_dists <- st_distance(x = nearest_pts_end_match,
                                  y = nearest_pts_end_match_shift,
                                  by_element = TRUE
                                  )
# There is a big jump between points 7 and 8.
```

```{r}
#| include: false
exdrive_plot_matched_og <- exdrive_plot |>
  st_set_geometry(st_geometry(nearest_pts_end_match))

nearest_pts_dist <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(exdrive_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id)

# Manually replace the 7th point with the next closest point
exdrive_plot_matched_alt7 <- exdrive_plot_matched_og
#exdrive_plot_matched_alt7$geometry[7] <- lwgeom::st_endpoint(nearest_pts_ls_sf$geometry[19])
exdrive_plot_matched_alt7$geometry[7] <- nearest_pts_dist$geometry[19]

mm_tmap_alt7 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(exdrive_plot_matched_alt7, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt7
```

```{r}
#| include: false
# Manually replace the sixth point with the next closest point
exdrive_plot_matched_alt76 <- exdrive_plot_matched_alt7
exdrive_plot_matched_alt76$geometry[6] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[16])

mm_tmap_alt76 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_sf_start, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(exdrive_plot_matched_alt76, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt76
```

```{r}
#| include: false
# Manually replace the fifth point with the next closest point
exdrive_plot_matched_alt765 <- exdrive_plot_matched_alt76
exdrive_plot_matched_alt765$geometry[5] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[15])
# The exact point may not matter here because it's matching to the endpoint shared by 2 segments.

mm_tmap_alt765 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_sf_start, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(exdrive_plot_matched_alt765, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt765
```

```{r}
#| echo: false
#| include: false
# Manually replace the fourth point with the next closest point
exdrive_plot_matched_alt7654 <- exdrive_plot_matched_alt765
exdrive_plot_matched_alt7654$geometry[4] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[12])
# The exact point may not matter here because it's matching to the endpoint shared by 2 segments.

# Now the fourth and fifth points are on top of each other at the corner.

# Get the lines between the original points and the matched points
alt_points <- bind_rows(exdrive_plot, exdrive_plot_matched_alt7654)
alt_points_ls <- alt_points |>
  group_by(time_utc) |>
  summarize() |>
  st_cast("LINESTRING")


exdrive_plot_matched_alt7654_ls <- 
  map2(.x = exdrive_plot$geometry, .y = exdrive_plot_matched_alt7654$geometry,
       \(x, y) st_union(x, y) |> st_cast("LINESTRING")) |>
  st_as_sfc() |>
  st_as_sf()

exdrive_plot_matched_alt7654_ls <- exdrive_plot_matched_alt7654_ls |>
  rename(geometry = "x")

# mm_tmap_alt7654 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#   tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "tan", lwd = 10) +
#   tm_shape(alt_points_ls, bbox = exdrive_bbox_adj) +
#   tm_lines(col = "black")+
#   tm_shape(nearest_pts_ls_sf_start, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
#   tm_shape(exdrive_plot_matched_alt7654, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)
# 
# mm_tmap_alt7654

mm_tmap_alt7654 <- example_tmap(road_system = poss_matches,
                               bbox = exdrive_bbox_adj,
                               og_points = exdrive_plot,
                               new_points = exdrive_plot_matched_alt7654,
                               match_lines = alt_points_ls)
mm_tmap_alt7654 <- mm_tmap_alt7654 + 
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))
mm_tmap_alt7654
```

```{r}
#| echo: false
poss_match_start <- lwgeom::st_startpoint(poss_matches)
poss_match_end <- lwgeom::st_endpoint(poss_matches)

road_bearings <- map2(.x = poss_match_start, .y = poss_match_end,
                      \(x, y) lwgeom::st_geod_azimuth(st_sfc(st_point(x), st_point(y), crs = 4326)) |>
                        units::set_units("degrees")) |>
  list_c()

poss_matches <- poss_matches |>
  mutate(bearing = 360 + as.numeric(road_bearings))

nearest_pts_ls_sf_id <- nearest_pts_ls_sf |>
  mutate(ObjectID = rep(poss_matches$ObjectID, length.out = nrow(nearest_pts_ls_sf)),
         time_utc = rep(exdrive_plot$time_utc, each = nrow(poss_matches)))

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id, 
                                          exdrive_plot |> select(time_utc, gyro_heading) |> st_drop_geometry(),
                                          by = "time_utc")

nearest_pts_ls_sf_id_heading <- left_join(nearest_pts_ls_sf_id_heading,
                                          poss_matches |> select(ObjectID, bearing) |> st_drop_geometry(),
                                          by = "ObjectID")

# Keep the points that have a heading within 45 degrees of the road segment heading
nearest_pts_heading_filter <- nearest_pts_ls_sf_id_heading |>
  mutate(abs_heading_dist = abs(gyro_heading - bearing)) |>
  filter(abs_heading_dist <= 45)

# Keep the closest point
nearest_pts_heading_filter_dist <- nearest_pts_heading_filter |>
  group_by(time_utc) |>
  filter(dist == min(dist))

nearest_pts_heading_filter_dist_start <- lwgeom::st_startpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_heading_filter_dist_end <- lwgeom::st_endpoint(nearest_pts_heading_filter_dist) |> 
  st_as_sf() |>
  rename(geometry = x)
```

It is reasonable to assume that the heading of a vehicle traveling on a road should be similar to the heading of the road, so roads should be removed from consideration if the vehicle heading and the road heading disagree. @whiteMapMatchingAlgorithms2000 explored this idea as a refinement of the point-to-curve map-matching method. An example of an approach like this is shown in @fig-map-matching-heading. Road segments with headings within 45 degrees of the vehicle heading were kept as candidates for matching. Note the temporal jump for the two points in the intersection for which the black lines indicating the match intersect. The last point with a westbound heading was closer to a different east-west road segment than the first three points with westbound headings, leading to a mismatch for the last point. Restricting candidate roads by heading ensured the first point with a southbound heading matched to the closest point on the north-south road.

:::{#fig-map-matching-heading}

```{r}
# mm_tmap_heading <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#   tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "tan", lwd = 10) +
#   tm_shape(nearest_pts_heading_filter_dist, bbox = exdrive_bbox_adj)+
#   tm_lines(col = "black")+
#   tm_shape(nearest_pts_heading_filter_dist_start, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
#   tm_shape(nearest_pts_heading_filter_dist_end, bbox = exdrive_bbox_adj)+
#   tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)
# 
# mm_tmap_heading 

# mm_tmap_heading <- example_tmap(road_system = poss_matches,
#                                 bbox = exdrive_bbox_adj,
#                                 og_points = nearest_pts_heading_filter_dist_start,
#                                 new_points = nearest_pts_heading_filter_dist_end,
#                                 match_lines = nearest_pts_heading_filter_dist)

mm_tmap_heading <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = exdrive_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_heading_filter_dist, bbox = exdrive_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(exdrive_plot #|> mutate(
    #gyro_heading = 360 - gyro_heading + 90) # use compass rose instead of unit circle representation
  ) + 
  tm_dots(size = 1, fill = "white", group = "original", group.control = "none", fill_alpha = 1)+ 
  tm_symbols(shape = "gyro_heading", size = 0.33, 
             shape.scale = tm_scale_intervals(
               style = "fixed",
               n = 5,
               #values = list(right, up, left, down, right),
               values = list(up_ca, right_ca, down_ca, left_ca, up_ca),
               breaks = c(0, 45, 135, 225, 315, 360)),
             group = "original", group.control = "none", 
             shape.legend = tm_legend(title = "Vehicle Heading\n(0 Degrees = North)")) +
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))+
  tm_shape(nearest_pts_heading_filter_dist_end, bbox = exdrive_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_heading <- mm_tmap_heading + 
  tm_shape(exdrive_plot, bbox = exdrive_bbox_adj)+
  tm_labels(text = "pt_label", xmod = 1.25, ymod = -0.5, options = opt_tm_labels(point.label = FALSE))
mm_tmap_heading
```

Example of the shortcomings of a geometric map-matching method that accounts for heading. The original GPS points (blue with white chevrons indicating the heading) were orthogonally projected onto the nearest road segment (red) after accounting for heading. Note the temporal jump of the two points near the intersection for which the black lines indicating the match intersect.
:::

Due to their poor performance, geometric map-matching methods have fallen out of favor in the literature. A vast array of more sophisticated map-matching algorithms employing a plethora of estimation techniques have been proposed. The work by @newsonHiddenMarkovMap2009 is widely regarded as seminal. They used hidden Markov models (HMMs) to find the most likely route on the road system corresponding to a time-stamped set of GPS coordinates while accounting for noisy data and the configuration of the road network. Hidden Markov models have since become a basis for many later map-matching algorithms [@sakiPracticalGuideOpenSource2022]. However, even sophisticated map-matching methods can still experience issues with incorrect road selection, such as those illustrated in @fig-naive-map-matching and @fig-map-matching-heading.

## Solving the Road Selection Problem {#sec-roadselection}

Most attention in the map-matching literature has been devoted to the road selection problem, with less attention going toward the position determination problem. Given this apparent imbalance in the literature and the importance of the position determination problem in applications, we decided to focus our research on the position determination problem. Autonomous vehicle localization is a related research area, but localization methods require data from additional sensors such as cameras and light detection and ranging (LiDAR) systems that are not available for connected vehicles and naturalistic driving study instrumentation packages.

Orthogonal projection is a common way to solve the position determination problem. Once the map-matching algorithm selects the road used by the vehicle, the vehicle's position on the road is determined by an orthogonal projection from the vehicle's recorded location onto the chosen road. The orthogonal projection location-determination method has been used from the earliest days of map-matching and continues to be widely utilized for vehicle position determination. For more recent uses of orthogonal projection for vehicle location determination, see, for example, @jimenezDefinitionEnhancedMapMatching2016 and @alkhazrajiEnhancingMapMatching2024.

Despite its widespread use and continued popularity, orthogonal projection is not the optimal way to solve the position determination problem in all cases. @greenfeldMatchingGPSObservations2002 observed that position errors and errors in the representation of the road system subsequently lead to errors in vehicle locations projected onto road segments. Thus, the actual location of the vehicle and its projected location on the road system may disagree. \mh{Orthogonal projection may also lead to a loss or misspecification of the temporal relationship between the recorded points. }Alternative strategies to orthogonal projection have been proposed.

In a map-matching method using the topology of the road network, @quddusGeneralMapMatching2003 used a weighted average of two points to estimate the vehicle's position on the chosen road segment. One of these points was obtained from the orthogonal projection of the observed vehicle location onto the road selected by the map-matching method. The location of the other point was calculated based on the previous location of the vehicle, the speed of the vehicle at the current time, and the bearing of the selected road segment for matching. A weighted average of the two points, with weights based on the error variances for the road network and the position sensor for the vehicle, provided the estimate of the vehicle's position on the selected road segment. Quddus and colleagues used similar approaches to solve the position determination problem in subsequent works [@ochiengMapmatchingComplexUrban2003; @quddusHighAccuracyFuzzy2006].

@quddusCurrentMapmatchingAlgorithms2007 described an approach used by @kimEfficientUseDigital2000 to solve the position determination problem. After selecting the correct road segment using a point-to-curve map-matching technique, Kim et al. used orthogonal projection onto the road segment as an initial estimate of the vehicle's location. Kim et al. then used an extended Kalman filter with inputs from the GPS position fixes to estimate the vehicle's position again, with the goal of minimizing the error in position along the road. Quddus et al. noted that the method of Kim et al. could be improved by using a better technique to select the correct road segment. Kalman filters remain an important component for data pre-processing in many map-matching algorithms and algorithms for vehicle trajectory prediction, e.g., works by @barriosImprovingEstimationVehicles2011, @wangMultisensorFusionMethod2014, and @ersanMapMatchingKalman2020. However, orthogonal projection still remains incredibly popular for vehicle position determination.

# Project Proposal {#sec-proposal}

As mentioned previously, there are many different map-matching algorithms. Many of these algorithms focus more heavily on the road selection problem than on the position determination problem. The position determination problem is essential for many applications, and thus is an important area for further research. We propose to develop a new method for solving the position determination problem to be used as a final step alongside powerful map-matching algorithms that perform road selection.

For the proposed method for vehicle position determination after map matching, we first need accurate road segments corresponding to the observed GPS points. If ground truth segment information is available, it will be utilized. To harmonize with the process currently used by InTrans for CV data, the closest road segments will be considered for these data. An advanced map-matching algorithm, such as one based on a hidden Markov model, will be used to provide highly accurate road segment selections from the map-matching algorithm when ground truth is unavailable.

Two comparison methods for position determination will be used. The first will be the standard orthogonal projection of the recorded GPS point onto the selected road. The second comparison method will be the weighted average method introduced by @quddusGeneralMapMatching2003. Recall from @sec-roadselection that Quddus et al.'s method uses the weighted average of the orthogonal projection point and a second point calculated based on the previous location of the vehicle, the speed of the vehicle at the current time, and the bearing of the selected road segment.

\mh{We propose to treat the position determination problem as a linkage problem. The inspiration came from patterns noticed in interactive, linked visualizations from our developmental R package DrivePlotR. The visualizations display a map of the vehicle trajectory alongside other variables, such as speed, heading, and GPS PDOP. Interactivity allows users to select and zoom in on points of interest. DrivePlotR visualizations make the spatio-temporal patterns in the data more apparent. Our linkage framework is based on the work of @taylorFastBayesianRecord2024.}

\mh{@taylorFastBayesianRecord2024 were interested in the task of record linkage in a streaming data context. Record linkage involves determining which observations in overlapping files of records came from the same entity. This task is made more challenging by noisy data sources and the frequent lack of a unique identifier for the entities. For example, a name may be spelled correctly as "John Smith" in one file, but spelled incorrectly as "Jon Smith" in another file. Record linkage identifies John Smith and Jon Smith as the same person. In a streaming data context, data files come in over time without a predetermined final number of data files.}

\mh{Suppose $k$ files $X_1, ..., X_k$ are collected over time. File $X_m$ is available at time $T_m$, with $T_1 < T_2 < ... < T_k$, and contains $n_m \geq 1$ records. Each file can potentially have a different number of records, and thus $n_m$ need not be the same for all files. The structure of file $X_m$ may be expressed as $X_m = \{\symbfit{x}_{mi}\}_{i=1}^{n_m}$. Each record includes $p_m$ fields. The set of $k$ files is assumed to have a common set of fields $F$, $f = 1, ..., F$ present in each file. @taylorFastBayesianRecord2024 assumed that each entity is present at most once in each file (i.e., there are no duplicates within a file).}

\mh{The function $\gamma(\symbfit{x}_{m_1i}, \symbfit{x}_{m_2j})$ compares two records, $\symbfit{x}_{m_1i}$ in file $X_{m_1}$ and $\symbfit{x}_{m_2j}$ in file $X_{m_2}$, by comparing the values in each common field $f$. Each field comparison yields discrete levels $0, ..., L_f$, and a value of $0$ indicates exact equality between the fields. Higher levels indicate increased difference between the fields for the two records. } 

\mh{@taylorFastBayesianRecord2024 defined $P=\sum_{f=1}^F (L_f+1)$ to be the total number of levels of disagreement for all fields. Then the comparison function $\gamma(\symbfit{x}_{m_1i}, \symbfit{x}_{m_2j})$ has the form of a $P$-vector of binary indicators with $F$ ones and $P-F$ zeros representing the level of disagreement in each common field between record $\symbfit{x}_{m_1i}$ and record $\symbfit{x}_{m_2j}$. The first $L_1+1$ elements of $\gamma(\symbfit{x}_{m_1i}, \symbfit{x}_{m_2j})$ must contain exactly one $1$, the next $L_2+1$ elements must also contain exactly one $1$, and so on. }

\mh{The comparison vectors are then collected into matrices $\Gamma^{(1)}, ..., \Gamma^{(k-1)}$. The comparison matrix $\Gamma^{(m-1)}$ contains all comparisons between the records in file $X_m$ and the records in all earlier files. The dimensions of $\Gamma^{(m-1)}$ are as follows: $n_m(n_1 + ... + n_{m-1})$ rows and $P$ columns. For $m \in 1, ..., k-1$, define $\Gamma^{(1:m)}$ as $\{\Gamma^{(1)}, ..., \Gamma^{(m)}\}$.}

\mh{We can represent records as $k$-partite graphs where nodes correspond to records in each file. An edge between two nodes indicates that their corresponding records refer to the same entity. We can also represent the graphs using $k-1$ matching vectors. Each file $X_2, ..., X_k$ has one matching vector. Let $\symbfit{Z}^{(m-1)}$ denote a matching vector. Then $\symbfit{Z}^{(m-1)}$ has length $n_m$ (the number of records in file $X_m$). Let $Z_j^{(m-1)}$ denote the value in index $j$ for $\symbfit{Z}^{(m-1)}$. $Z_j^{(m-1)}$ corresponds to the record $\symbfit{x}_{mj}$ as follows:}

$$
\begin{aligned}
Z_j^{(m-1)} = 
\begin{cases}
\sum_{\ell=1}^{t-1} n_\ell + i &\text{for } t < m,\text{ if } \symbfit{x}_{ti} \in X_t \text{ and } \symbfit{x}_{mj} \text{ are coreferent}\\
\sum_{\ell=1}^{m-1} n_\ell + j &\text{otherwise}
\end{cases}
\end{aligned}
$${#eq-jvalue}

\mh{For $m \in 1, ..., k-1$, define $\symbfit{Z}^{(m-)} = \left(Z_j^{(m-1)}\right)_{j=1}^{n_m}$ and $\symbfit{Z^{(1:m)}} = \left\{\symbfit{Z}^{(1)}, ..., \symbfit{Z}^{(m)}\right\}$. These vectors indicate which records refer to the same entity, and thus are parameters of interest in the record linkage problem.}

\mh{Recall that a record for an entity can appear at most once in each data file. Thus, all of the records corresponding to a specific entity may be represented as a chain of links from the most recent record back to the earliest record. Records are linked in the order they appeared. Thus, all records corresponding to a specific entity may be identified by starting at one link in the chain and traversing the chain forwards and backwards. New links are added to the chain and older links may be updated as new data files arrive.}

\mh{We will use a multivariate approach for the position-determination problem. We will incorporate variables such as time, vehicle location (latitude/longitude), speed, heading, etc. The goal is to establish the linkage between the vehicle's recorded GPS and the road segment selected by the map-matching algorithm, while accounting for time. As new vehicle locations arrive, we will be able to update our previous estimates of the vehicle's position on the selected road segment. It is of particular interest to identify the points where the road segment changes (e.g., turns) and adjust the other points accordingly. Visuals from DrivePlotR will be a key component in determining the conditions under which the points should be adjusted and how the adjustments should be made.}

<!-- There are several potential directions to be pursued to create our new method (or methods). First, we could follow the lead of @kimEfficientUseDigital2000 in exploring the use of a Kalman filter for position determination, but also follow the recommendation of @quddusCurrentMapmatchingAlgorithms2007 by using a more accurate algorithm (or ground truth) for road selection. We are also interested in treating the map-matching process as a two-level linkage problem, with the road selection problem being the first level and the position determination problem being the second level. (See, for example, @taylorFastBayesianRecord2024.) Third, note that any projection that is not an orthogonal projection is called an oblique projection. Since we want to provide an alternative to orthogonal projection for vehicle position determination, it is natural to think of using an oblique projection instead. We could find vehicle positions using an oblique least squares approximation [@mccartinObliqueLinearLeast2010]. Our case differs from the typical case for oblique least squares in that we know the line onto which the GPS points should be projected (i.e., the selected road segment), but do not know the direction (or slope) of the projection. Other methods of interest may be identified as the research progresses. -->

Thus, we can utilize highly accurate estimates for the road on which a vehicle is driving and combine them with a more precise position determination method than is achievable from simple orthogonal projection onto the selected road segment. The separation from the map-matching algorithm for road selection will allow our position determination algorithm to be used with any existing or yet-to-be-proposed map-matching algorithm for road selection. Our work will also include novel ways to visualize large-scale spatio-temporal transportation data \mh{with DrivePlotR} and unlock new insights from applications. These new insights will not be possible without new ways to visualize large-scale spatio-temporal transportation data and an improved method to determine the positions of vehicles on the road system after matching.

# Proposed Chapter Overviews

## Chapter 0: Literature Review & Problem Statement

This chapter presents an overview of the data sources used in this project and the challenges uncovered in their use. Telematics data are discussed, and an overview of GPS and related quality measures are presented. Prior work on the map-matching problem is discussed. The new contributions of the work are explained.

## Chapter 1: Software Tools for Large-Scale Spatio-Temporal Transportation Data

This chapter discusses software tools developed for visualizing large-scale spatio-temporal transportation data and explains how insights based on the visualizations led to subsequent work.

## Chapter 2: Detecting Driving Behavior from Large-Scale Spatio-Temporal Transportation Data

This chapter explains how driving behavior may be detected from telematics data. An application to cognitive health in older drivers is presented.

## Chapter 3: Determining Precise Vehicle Locations on the Road System

This chapter covers a new method for determining a vehicle's location on a road segment after a map-matching algorithm is used. An application using this method is discussed.

<!-- \mh{Both the reported locations in a vehicle's trajectory and the road system used in the map-matching process are subject to error, which leads to uncertainty in the revised locations produced by the map-matching process. @quddusIntegrityMapmatchingAlgorithms2006 developed a metric for the integrity of map-matching algorithms. The results indicated that both the capability of the map-matching algorithm and the resolution of the digital map of the road system affect affect the integrity of the method.} -->


<!-- @newsonHiddenMarkovMap2009 provide one example vehicle trajectory from a route in Seattle, Washington, USA, along with the ground truth route traveled by the vehicle. @kubickaDatasetTestingTraining2015 provide one hundred example vehicle trajectories from various locations around the world along with a map-matched route for each trajectory. However, the true sequence of road segments traveled in each of these trajectories are unknown, and thus the matched routes represent experts' best ideas for the correct sequence of road segments. The sets of example trajectories from Newson and Krumm and Kubička et al. focus more on the determination of the road segment on which the vehicle was traveling at each time point as opposed to the location of the vehicle on the selected link. -->




# References

\sloppy
<!-- Inspired by https://github.com/jgm/pandoc/issues/10921 -->

::: {#refs}
:::

\newpage

# Appendix {.appendix .unnumbered}

\setcounter{table}{0}
\renewcommand{\thetable}{A\arabic{table}}

:::{#tbl-rwrad}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.33\textwidth}|p{0.33\textwidth}|}
\hline
 %\multicolumn{3}{| c |}{Beginning of Table}\\
 %\hline
 Variable & Units/Values & Description\\
 \hline
 \endfirsthead
 
 \hline
 \multicolumn{3}{|c|}{Continued from previous page}\\
 \hline
 Variable & Units/Values & Description\\
 \hline
 \endhead
 
 \hline
 \endfoot

\hline
%\multicolumn{3}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

device & NA & Device ID of Black Box\\
\hline
drive & NA & Numeric value sequentially ordered across time indicating the drive number to which the data correspond\\
\hline
time\_utc & yyyy-mm-dd hh:mm:ss & Date timestamp in UTC\\
\hline
gps\_long & Decimal degrees & Longitude returned from GPS\\
\hline
gps\_lat & Decimal degrees & Latitude returned from GPS\\
\hline
gps\_elevation & Meters & Elevation returned from GPS\\
\hline
gps\_heading & Degrees & Direction over the ground the vehicle is currently moving (returned from GPS)\\
\hline
gps\_fix & 0 = no fix\newline 1 = time only\newline 2 = 2D fix (latitude and longitude)\newline 3 = 3D fix (latitude, longtitude, and elevation) & Value representing the quality of the connection (or ``fix") between the GPS receiver and the GPS satellite constellation. A fix type of 2 gives good GPS location data, but applications that need more precise location estimates (e.g., applications relying on GPS speed) should use a fix type of 3. Theoretically, a fix type of 1 is the worst quality fix type that gives GPS time information, but data inspection suggests that for this study, the worst fix type giving GPS time information may actually be 2.\\
\hline
gps\_sats & NA & Number of satellites the GPS can ``see"\\
\hline
gps\_pdop & \textless{}1 = Ideal\newline 1-2 = Excellent\newline 2-5 = Good\newline 5-10 = Moderate\newline 10-20 = Fair\newline \textgreater{}20 = Poor\newline & Dilution of precision measure for 3D position\\
\hline
gps\_hdop & See gps\_pdop & Dilution of precision for the horizontal plane\\
\hline
gps\_vdop & See gps\_pdop & Dilution of precision for the vertical axis\\
\hline
gyro\_x & Degrees/second & Angular rotation rate about the right-to-left axis\\
\hline
gyro\_y & Degrees/second & Angular rotation rate about the forward-to-backward axis\\
\hline
gyro\_z & Degrees/second & Angular rotation rate about the up-to-down axis\\
\end{longtable}
```

Metadata for UNMC naturalistic driving study.
:::

:::{#tbl-cvmetadata}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.08\textwidth}|p{0.1\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.1\textwidth}|}
\hline
 %\multicolumn{6}{| c |}{Beginning of Table}\\
 %\hline
 Field & Source & Units & Description & Possible Issues & Domains\\
 \hline
 \endfirsthead
 
\hline
 \multicolumn{6}{|c|}{Continued from previous page}\\
 \hline
 Field & Source & Units & Description & Possible Issues & Domains\\
 \hline
 \endhead

\hline
\endfoot

\hline
%\multicolumn{6}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

datapoint\_id & Derived & NA & Unique identifier for each data point & &\\
\hline
journey\_id & Raw & NA & Unique identifier for each vehicle journey. The journey ID represents the same vehicle from ignition on to ignition off. & Streetlight notified InTrans that some journey IDs are non-compliant due to not having an ignition on/off, typically due to data coming in late. & \\    
\hline
capture\_time\_stamp & Raw & yyyy-mm-dd hh:mm:ss & Timestamp of the data in Central Time & & \\
\hline
latitude & Raw & Decimal degrees WGS 84 & Latitude value for the data point & & \\
\hline
longitude & Raw & Decimal degrees WGS 84 & Longitude value for the data point & & \\
\hline
heading\_deg & Raw & Degrees & Direction the vehicle is traveling, where 0 degrees is East, 90 is North, 180 is West and 270 is South. & & \\
\hline
elevation\_ft & Raw & Feet & Vertical distance above sea level measured in feet & & \\
\hline
speed\_mph & Raw & Miles per hour & Speed of the vehicle for the data point (collected by in-vehicle instrumentation) & & \\
\hline
acceleration & Derived & $\text{ft/s}^2$ & Derived acceleration between the previous data point and the current data point for the journey & & \\
\hline
ignition\_status & Raw & NA & Identifies whether the data point is at the beginning/end of the trip or part of the middle of the trip & & MIDTRIP, KEYON, KEYOFF  \\
\hline
route\_id & Derived & NA & Route ID of the closest segment to the data point & & \\
\hline
measure & Derived & Miles & Precise measure value along the route ID segments to the data point. The segmentation is based on the Iowa DOT RAMS network. & & \\
\hline
distance\_from\_route & Derived & Feet & Distance from the data point to the centerline of the RAMS network segment & Data points in parking lots and fields will still be associated to the closest roadway. & \\
\hline
segment\_start\_measure & Derived & Miles & Segment start measure value along the route ID segments to the data point & & \\
\hline
segment\_end\_measure & Derived & Miles & Segment end measure value along the route ID segments to the data point & & \\
\hline
geohash & Derived & NA & Unique identifier for a specific region on earth & &  \href{https://www.ibm.com/docs/en/streams/4.3.0?topic=334-geohashes}{Geohash documentation}  \\
\hline
masking\_digit & Derived & NA & Number of digits in the latitude or longitude (whichever is smaller). Used to identify whether the data is masked (value less than 5). & & \\
\hline
year & Derived & NA & Year partition in which the data point was downloaded (not necessarily the year of the capture time stamp) & & \\
\hline
county\_id & Derived & NA & County where the data point is located. The county is represented by a number which can be identified at the RAMS link in the domain. & & \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer/43}{RAMS}\\
\hline
month & Derived & NA & Month partition in which the data point was downloaded (not necessarily the month of the capture time stamp) & & \\
\hline
day & Derived & NA & Day of month partition in which the data point was downloaded (not necessarily the day of the capture time stamp) & & \\
\hline
hour & Derived & NA & Hour partition in which the data point was downloaded (not necessarily the hour of the capture time stamp) & & \\
\end{longtable}
```

Connected Vehicle Metadata.
:::

:::{#tbl-roadnetwork}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.08\textwidth}|p{0.1\textwidth}|p{0.25\textwidth}|p{0.15\textwidth}|}
\hline
 %\multicolumn{5}{| c |}{Beginning of Table}\\
 %\hline
 Field & Source & Units & Description & Domains\\
 \hline
 \endfirsthead
 
\hline
 \multicolumn{5}{|c|}{Continued from previous page}\\
 \hline
 Field & Source & Units & Description & Domains\\
 \hline
 \endhead

\hline
\endfoot

\hline
%\multicolumn{5}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

route\_id & RAMS & NA & Unique identifier for a route. The segmentation is based on the Iowa DOT’s \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer}{RAMS network}. &  \\
\hline
route\_from\_measure & RAMS & Miles & \textbf{Do not recommend using.} This field is the minimum measure for a route, but does not represent the actual location of the segment. & \\
\hline
route\_to\_measure & RAMS & Miles & \textbf{Do not recommend using.} This field is the maximum measure for a route, but does not represent the actual location of the segment. & \\
\hline
segment\_start\_latitude & RAMS & Decimal degrees  & Latitude of the start of the segment along the RAMS network  & \\
\hline
segment\_start\_longitude & RAMS & Decimal degrees & Longitude of the start of the segment along the RAMS network & \\
\hline
segment\_end\_latitude & RAMS & Decimal degrees & Latitude of the end of the segment along the RAMS network & \\
\hline
segment\_end\_longitude & RAMS & Decimal degrees & Longitude of the end of the segment along the RAMS network & \\
\hline
segment\_start\_measure & RAMS & Miles & Measure at the beginning of the segment along the RAMS network. \textbf{This field should be used when relating to the CV data.} & \\
\hline
segment\_end\_measure & RAMS & Miles & Measure at the end of the segment along the RAMS network. \textbf{This field should be used when relating to the CV data.} & \\
\hline
segment\_length & RAMS & Miles & Calculated distance of the segment based on the difference between the \texttt{segment\_start\_measure} and \texttt{segment\_end\_measure} & \\
\hline
geohash\_lrs & Derived & NA & Unique identifier for a specific region on earth that can be used to identify a specific location for filtering data & \href{https://www.ibm.com/docs/en/streams/4.3.0?topic=334-geohashes}{IBM geohash documentation} \\
\hline
bearing & Derived & Degrees & Direction of the roadway in degrees (not the same as CV data), where 0 degrees is North, 90 is East, 180 is South and 270 is West. For divided or one way roadways, the bearing represents the direction of travel for vehicles. For undivded roadways, the bearing represents the primary direction (North or East) of vehicles (but vehicles can also travel in the opposite direction of the bearing). & \\
\hline
facility\_type & RAMS & NA & Type of roadway the segment is defined as in RAMS & \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer/44}{RAMS facility types}\\
\end{longtable}
```

Road network metadata.
:::
