---
title: "Problem Overview"
author: "Marie Hardt"
bibliography: "`r rbbt::bbt_write_bib('overviewreferences.bib', keys=rbbt::bbt_detect_citations(here::here('problem_overview.qmd')),
   ignore = stringr::str_subset(rbbt::bbt_detect_citations(here::here('problem_overview.qmd')), '(^fig-|^tbl-|^eq-|^sec-|^lst-|^thm-|^lem-|^cor-|^prp-|^cnj-|^def-|^exm-|^exr-)'), overwrite = TRUE, library_id='Graphics-Research', translator='bibtex')`"
number-sections: true
header-includes:
   - \usepackage{hyperref}
   - \usepackage[dvipsnames]{xcolor} % colors
   - \usepackage{longtable}
   - \newcommand{\mh}[1]{{\textcolor{teal}{#1}}}
   - \newcommand{\gb}[1]{{\textcolor{RedOrange}{#1}}}
   - \newcommand{\hh}[1]{{\textcolor{Green}{#1}}}

format:
  pdf:
    keep-tex: true
    fontsize: 11pt
    toc: true
    link-citations: true
    geometry:
      - right=1in
      - left=1in
      - top=1in
      - bottom=1in

filters:
   - latex-environment
commands: [rr,svp,hh]    
---

```{r setup}
#| echo: false
#| warning: false
#| message: false
library(rbbt)
library(tidyverse)
library(leaflet)
library(sf)
library(glue)
# remotes::install_github("hardtme/DrivePlotR)
library(DrivePlotR)
library(tmap)
tmap_mode("plot")
# remotes::install_github("dill/emoGG")
library(emoGG)
library(gpsdriving)
```

# To Dos


\mh{To do items for the data sources}

\mh{1. Find a good example that you can use to show the geospatial drift you mention and create code for a picture for both the NDS and the CV data.}

\mh{2. For the NDS data, shift the data manually (using a single delta x, delta y for a shift) to the right place, and save that as the ‘target’. Calculate the sum of squares between the before and after locations. That is going to be our error for that example and will serve as the baseline to measure progress.}

\mh{3. I am not completely sure what a GPS error will look like in the CV data. What I am hoping for is a time dependent GPS drift, when all of the measurements will shift by a delta x, delta y. If that is a case, we can proceed with creating an example in the same way as (2). If not, keep track of how the error is showing itself.}

\mh{4. (For Later) We will need a couple more of these training examples, but let’s focus on the documentation of the first two examples first.}

\mh{5. Try to quantify the error in GPS data more - not necessarily for the overview, but to document the need for an algorithm. This might be best done by a general discussion of how GPS quality is determined and a specific summary of how ‘good’ the GPS is in the NDS study and the connected vehicles}


# Introduction {#sec-introduction}

\hh{XXX The purpose of this first section is to motivate  your work by answering What? and Why?}

\hh{XXX What is at the heart of your work? Spatio-temporal processes. As human beings we are surrounded by spatio-temporal processes. With increasing technology a lot of these processes are being captured quantitatively, and we are relying on a lot of devices that make use of capturing these quantities. }

We increasingly rely on connected devices to improve the quality of our lives. For example, navigation apps in our smartphones make it easy to navigate to anywhere we need to go. Such smart devices provide a wealth of data about complex spatio-temporal processes. However, even the most sophisticated smart devices can fail and return obviously incorrect data, such as location data for driving trips that fall nowhere near a roadway. Such erroneous data must be cleaned and corrected before they can be used to develop insight in applications. We created new statistical methods to orthogonally project driving trip trajectories onto the road system. We also developed tools for working with and visualizing spatio-temporal data such as driving trip trajectories. 

\hh{XXX The following sentence is the answer to a How? question - it doesn't motivate.}
For this project, we use two primary data sources: naturalistic driving study (NDS) data and connected vehicle (CV) data. Both of these data sources, make extensive use of location information from the Global Positioning System (GPS). We first discuss some essential background regarding GPS data in @sec-gps, @sec-dop, and @sec-crs. We describe NDS data in @sec-nds and also describe CV data in @sec-cv. @sec-problemoverview provides an overview of some methods used to orthogonally project GPS location information onto the road system.

## Global Positioning System {#sec-gps}

The Global Positioning System (GPS) is part of the Global Navigation Satellite System (GNSS), which provides accurate location and navigation information. Any GNSS (including GPS) involves a constellation of satellites orbiting the Earth in a specified pattern. Typically, 6 to 10 of the satellites in the constellation are above the horizon at any time, but not all of the satellites may be usable by the receiver due to obstructions like tall buildings. A ground-based network of monitoring and control stations continually determines the orbital paths of the satellites in the constellation. The ground stations make short-term predictions of the satellites' locations in orbit and transmit these predictions back to the satellites. The satellites then relay their positions to receivers [@iliffeDatumsMapProjections2008]. @fig-gps shows simplified depictions of signals being transmitted from GPS satellites in orbit to a receiver in a vehicle on the ground. GPS satellite constellation geometry is discussed further in @sec-dop. 

```{r}
#| echo: false
#| layout-ncol: 2
#| fig-cap: "Examples of GPS satellite constellation geometries"
#| fig-subcap: 
#|  - "Poor geometry"
#|  - "Good geometry"
#| label: fig-gps

receiver <- data.frame( x = 0, y = 0)

bad_satellites <- data.frame(x = c(-0.7, -0.3, -0.5, -0.8),
                             y = c(7.5, 9.75, 9, 6.5))

good_satellites <- data.frame(x = c(1, -1, -0.3, 0.4),
                         y = c(7, 8, 10, 9.5))

bad_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_emoji(data = bad_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = bad_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(0, 10))
bad_sats

good_sats <- ggplot() +
  geom_emoji(data = receiver, mapping = aes(x = x, y = y), emoji = "1f697") +
  geom_emoji(data = good_satellites, mapping = aes(x = x, y = y), emoji = "1f6f0")+
  geom_segment(data = good_satellites, aes(x = 0, y = 0, xend = x, yend = y), linewidth = 0.2)+
  theme_void() +
  theme(panel.background = element_rect(fill = "lightblue1"))+
  scale_y_continuous(limits = c(0, 10))
good_sats

```

GPS satellites send information to receivers by modulating the information onto a set of underlying carrier waves of specified frequencies. In addition to satellite location information and general system information, each satellite also transmits a pre-determined sequence of binary codes at particular times. These codes can be thought of as time information if the user can receive them. To aid the process in the case of weak signals, the GPS receiver already stores a copy of the code to give it an idea of what to expect. The GPS receiver generates the code itself and then finds the time offset between its own code and the code it receives from the satellite, thus finding the signal's travel time [@iliffeDatumsMapProjections2008].

The distance from the GPS receiver to the satellite can be calculated by multiplying the signal's travel time by the signal's transmission speed (i.e., the speed of light). Theoretically, it should be possible to determine the GPS receiver's location based on observations from three satellites and solving a simultaneous system of three equations in three unknowns (say X, Y, Z). However, there is a problem with this method because the satellite clock and the receiver clock are not synchronized with each other. GPS satellites use very precise atomic clocks that are continuously monitored by the ground stations, but receivers must make do with much cheaper, less accurate clocks. Since light travels approximately 300,000 km/s, an offset of 1 second between the satellite clock and the receiver clock will lead to a 300,000 km error in the distance calculation. To solve the problem, a fourth satellite is needed. Then the offset between the satellite times and the receiver time can be included in a simultaneous system of four equations in four unknowns (say X, Y, Z, $\Delta t$) [@iliffeDatumsMapProjections2008].

## Dilution of Precision {#sec-dop}

Even when four or more satellites are visible to the GPS receiver, GPS location measurements are not immune to errors. Errors may arise from a variety of sources, including satellite errors, transmission errors, environmental errors, and receiver errors [@isikIntegrityAnalysisGPSBased2020].

Dilution of Precision (DOP) coefficients are unitless measurements representing the relative positions of navigation satellites and the receiver and the influence of the relative positions on the location obtained [@isikIntegrityAnalysisGPSBased2020]. There are multiple different types of DOP coefficients, each accounting for a different location aspect. We have three DOP types in the NDS data we used: Position DOP (PDOP), Horizontal DOP (HDOP), and Vertical DOP (VDOP).

@isikIntegrityAnalysisGPSBased2020 presented the following relationship among the DOP coefficients we have available in the NDS data we used:

$$
\begin{aligned}
\text{PDOP} &= \sqrt{\text{HDOP}^2 + \text{VDOP}^2}\\
\end{aligned}
$$

@isikIntegrityAnalysisGPSBased2020 also showed how to calculate the DOP coefficients. Let $\theta_1$, $\theta_2$, $\theta_3$, and $\theta_4$ denote the elevations above the receiver's horizon of the four best satellites for calculating DOP coefficients. Also let $\varphi_1$, $\varphi_2$, $\varphi_3$, and $\varphi_4$ denote the azimuths (i.e., the direction away from the receiver) of the four best satellites. Then we have

$$
\begin{aligned}
G &= \begin{bmatrix}
-\cos(\theta_1)\sin(\varphi_1) & -\cos(\theta_1)\cos(\varphi_1) & -\sin(\theta_1) & 1\\
-\cos(\theta_2)\sin(\varphi_2) & -\cos(\theta_2)\cos(\varphi_2) & -\sin(\theta_2) & 1\\
-\cos(\theta_3)\sin(\varphi_3) & -\cos(\theta_3)\cos(\varphi_3) & -\sin(\theta_3) & 1\\
-\cos(\theta_4)\sin(\varphi_4) & -\cos(\theta_4)\cos(\varphi_4) & -\sin(\theta_4) & 1\\
\end{bmatrix}\\
H &= \left(G^T \cdot G\right)^{-1}\\
\text{PDOP} &= \sqrt{H_{11} H_{22} H_{33}}\\
\text{HDOP} &= \sqrt{H_{11} H_{22}}\\
\text{VDOP} &= \sqrt{H_{33}}
\end{aligned}
$$

Higher DOP coefficients indicate worse positional accuracy, and two main factors increase DOP coefficients: sub-optimal geometry of the satellite constellation and obscured satellites [@isikIntegrityAnalysisGPSBased2020]. Even under ideal conditions, the geometry of the satellite constellation visible to the receiver constantly changes due to the movement of the satellites and the receiver. For DOP calculations, four satellites that are further apart in the sky (as visible from the receiver) are more optimal than four satellites that are close together in the sky, as shown in @fig-gps. Satellite obscuration prevents some satellites from being visible to the receiver. Tall buildings in urban areas commonly obscure satellites, which is a problem because the receiver cannot see more optimal satellites and must instead rely on a suboptimal satellite constellation to determine location [@isikIntegrityAnalysisGPSBased2020].

@isikIntegrityAnalysisGPSBased2020 noted that there is no agreed-upon standard for relating DOP coefficient values to the quality of navigation data. Recall that lower DOP coefficient values should indicate higher quality navigation data. @isikIntegrityAnalysisGPSBased2020 presented the scale for DOP coefficient values shown in @tbl-dop based on the literature and the results of their own work.

:::{#tbl-dop}

```{=latex}
\begin{table}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
DOP Value             & $<1$  & $1-2$     & $2-5$ & $5-10$   & $10-20$ & $>20$ \\ \hline
Location Data Quality & Ideal & Excellent & Good  & Moderate & Fair    & Poor  \\ \hline
\end{tabular}
\end{table}
```

Scale relating the value of dilution of precision (DOP) coefficients to location data quality [@isikIntegrityAnalysisGPSBased2020]
:::

## Coordinate Reference Systems {#sec-crs}

To work with location data, we must know the coordinate reference system for the data. Coordinate reference systems arise from the positioning and orienting of a coordinate system with respect to a datum [@iliffeDatumsMapProjections2008]. For any coordinate system, the system dimension, or the number of axes for the system, must be defined. We also need to know the name of each axis, the order of the axes (which in turn gives the order of coordinates), the direction in which coordinates increase along the axes, and the measurement units for the axes [@iliffeDatumsMapProjections2008]. Coordinate systems for the approximately spherical (actually ellipsoidal) Earth use three axes: latitude (the angle north or south of the equatorial plane), longitude (the angle east or west from a specified prime meridian), and height (the distance above the surface of the Earth) [@iliffeDatumsMapProjections2008].

However, latitude and longitude coordinates are ambiguous without information about the datum used to relate the coordinate system to the Earth's surface [@iliffeDatumsMapProjections2008]. The Earth's true shape is called the geoid, and a geodetic datum relates an ellipsoidal approximation of the shape of the Earth to the geoid [@iliffeDatumsMapProjections2008]. A datum must be realized through physical monuments of established coordinates in the area of interest before it can be used [@iliffeDatumsMapProjections2008]. A coordinate reference system (CRS) is a coordinate system associated to an object through the use of a datum [@iliffeDatumsMapProjections2008].

Since the geolocation data for this project come from GPS, the primary CRS used in this project is the World Geodetic System of 1984, abbreviated WGS 84. WGS 84 is the CRS for GPS locations. @iliffeDatumsMapProjections2008 note that the starting points for WGS 84 are the orbital positions transmitted by the GPS satellites and determined by a network of monitoring stations maintained by the United States military. The WGS 84 datum is realized by the coordinates of these monitoring stations [@iliffeDatumsMapProjections2008].

Map projections must be used to visualize locations from the three-dimensional surface of the Earth on a two-dimensional map [@iliffeDatumsMapProjections2008]. However, spheres and ellipsoids cannot be projected onto a flat surface like a map without distorting or cutting them. Such distortion should not be considered an error, however, because the method of projection is known and the true coordinates in the original, unprojected CRS may be obtained if the projection parameters are known [@iliffeDatumsMapProjections2008]. For example, interactive maps created with the R package `leaflet` [@chengLeafletCreateInteractive2024] expect that the input coordinates use the WGS 84 CRS and the WGS 84 Web Mercator projection is used to project the coordinates onto a two-dimensional map.

# Driving Data Sources {#sec-drivingdatasources}

## Naturalistic Driving Study Data {#sec-nds}

Naturalistic driving studies are a source of multivariate high resolution spatiotemporal driving data. Participants in a naturalistic driving study (NDS) consent to have a data acquisition system (DAS) installed in their vehicles during the study period so their driving behaviors can be monitored and recorded. A notable example of an NDS is the one administered by the Transportation
Research Board of the National Academies as part of the
Second Highway Research Program (SHRP 2), which aimed to understand how driver performance and behavior impact traffic safety. For the SHRP 2 NDS, study participants from
six different US states consented to have their driving monitored by an in-vehicle DAS equipped with various data collection channels, including video cameras, a global positioning system (GPS) unit, and accelerometers, among others [@campbellSHRP2Naturalistic2012]. The Longitudinal Research on Aging Drivers (LongROAD) study was a more recent NDS that focused on collecting data from participants aged 65 to 79 to better understand how medical, behavioral, environmental, and technological factors influence road safety as drivers age [@liLongitudinalResearchAging2017].

This project utilized data from an NDS conducted by the University of Nebraska Medical Center (UNMC). This NDS aimed to use driving data from older drivers to develop biomarkers for early detection and monitoring of cognitive decline. The variables available in the processed UNMC NDS data are described (as per the internal study documentation) in @tbl-rwrad.

<!-- From the file BlackBox_FormatQAPass_DataDictionary.docx -->

:::{#tbl-rwrad}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.33\textwidth}|p{0.33\textwidth}|}
\hline
 %\multicolumn{3}{| c |}{Beginning of Table}\\
 %\hline
 Variable & Units/Values & Description\\
 \hline
 \endfirsthead
 
 \hline
 \multicolumn{3}{|c|}{Continued from previous page}\\
 \hline
 Variable & Units/Values & Description\\
 \hline
 \endhead
 
 \hline
 \endfoot

\hline
%\multicolumn{3}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

device & NA & Device ID of Black Box\\
\hline
drive & NA & Numeric value sequentially ordered across time indicating the drive number to which the data correspond\\
\hline
time\_utc & yyyy-mm-dd hh:mm:ss & Date timestamp in UTC\\
\hline
gps\_long & Decimal degrees & Longitude returned from GPS\\
\hline
gps\_lat & Decimal degrees & Latitude returned from GPS\\
\hline
gps\_elevation & Meters & Elevation returned from GPS\\
\hline
gps\_heading & Degrees & Direction over the ground the vehicle is currently moving (returned from GPS)\\
\hline
gps\_fix & 0 = no fix\newline 1 = time only\newline 2 = 2D fix (latitude and longitude)\newline 3 = 3D fix (latitude, longtitude, and elevation) & Value representing the quality of the connection (or ``fix") between the GPS receiver and the GPS satellite constellation. A fix type of 2 gives good GPS location data, but applications that need more precise location estimates (e.g., applications relying on GPS speed) should use a fix type of 3. Theoretically, a fix type of 1 is the worst quality fix type that gives GPS time information, but data inspection suggests that for this study, the worst fix type giving GPS time information may actually be 2.\\
\hline
gps\_sats & NA & Number of satellites the GPS can ``see"\\
\hline
gps\_pdop & \textless{}1 = Ideal\newline 1-2 = Excellent\newline 2-5 = Good\newline 5-10 = Moderate\newline 10-20 = Fair\newline \textgreater{}20 = Poor\newline & Dilution of precision measure for 3D position\\
\hline
gps\_hdop & See gps\_pdop & Dilution of precision for the horizontal plane\\
\hline
gps\_vdop & See gps\_pdop & Dilution of precision for the vertical axis\\
\hline
gyro\_x & Degrees/second & Angular rotation rate about the right-to-left axis\\
\hline
gyro\_y & Degrees/second & Angular rotation rate about the forward-to-backward axis\\
\hline
gyro\_z & Degrees/second & Angular rotation rate about the up-to-down axis\\
\end{longtable}
```

Metadata for UNMC naturalistic driving study
:::

## Connected Vehicle Data {#sec-cv}

The CV data come from the data provider StreetLight and are available from the Institute for Transportation (InTrans) at Iowa State University. The connected vehicles directly provide trajectory information every 1-3 seconds throughout their journeys. Each trip is uniquely identified by a unique JourneyID and each data point has a unique DatapointID (InTrans internal documentation, 2025).

Connected vehicles collect a variety of data throughout their journeys, including vehicle location, speed, and heading. Other variables, such as acceleration, are derived from the data. @tbl-cvmetadata provides an overview of the available variables in the CV data, as described in the InTrans internal documentation.

:::{#tbl-cvmetadata}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.08\textwidth}|p{0.1\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.1\textwidth}|}
\hline
 %\multicolumn{6}{| c |}{Beginning of Table}\\
 %\hline
 Field & Source & Units & Description & Possible Issues & Domains\\
 \hline
 \endfirsthead
 
\hline
 \multicolumn{6}{|c|}{Continued from previous page}\\
 \hline
 Field & Source & Units & Description & Possible Issues & Domains\\
 \hline
 \endhead

\hline
\endfoot

\hline
%\multicolumn{6}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

datapoint\_id & Derived & NA & Unique identifier for each data point & &\\
\hline
journey\_id & Raw & NA & Unique identifier for each vehicle journey. The journey ID represents the same vehicle from ignition on to ignition off. & Streetlight notified InTrans that some journey IDs are non-compliant due to not having an ignition on/off, typically due to data coming in late. & \\    
\hline
capture\_time\_stamp & Raw & yyyy-mm-dd hh:mm:ss & Timestamp of the data in Central Time & & \\
\hline
latitude & Raw & Decimal degrees WGS 84 & Latitude value for the data point & & \\
\hline
longitude & Raw & Decimal degrees WGS 84 & Longitude value for the data point & & \\
\hline
heading\_deg & Raw & Degrees & Direction the vehicle is traveling, where 0 degrees is East, 90 is North, 180 is West and 270 is South. & & \\
\hline
elevation\_ft & Raw & Feet & Vertical distance above sea level measured in feet & & \\
\hline
speed\_mph & Raw & Miles per hour & Speed of the vehicle for the data point (collected by in-vehicle instrumentation) & & \\
\hline
acceleration & Derived & $\text{ft/s}^2$ & Derived acceleration between the previous data point and the current data point for the journey & & \\
\hline
ignition\_status & Raw & NA & Identifies whether the data point is at the beginning/end of the trip or part of the middle of the trip & & MIDTRIP, KEYON, KEYOFF  \\
\hline
route\_id & Derived & NA & Route ID of the closest segment to the data point & & \\
\hline
measure & Derived & Miles & Precise measure value along the route ID segments to the data point. The segmentation is based on the Iowa DOT RAMS network. & & \\
\hline
distance\_from\_route & Derived & Feet & Distance from the data point to the centerline of the RAMS network segment & Data points in parking lots and fields will still be associated to the closest roadway. & \\
\hline
segment\_start\_measure & Derived & Miles & Segment start measure value along the route ID segments to the data point & & \\
\hline
segment\_end\_measure & Derived & Miles & Segment end measure value along the route ID segments to the data point & & \\
\hline
geohash & Derived & NA & Unique identifier for a specific region on earth & &  \href{https://www.ibm.com/docs/en/streams/4.3.0?topic=334-geohashes}{Geohash documentation}  \\
\hline
masking\_digit & Derived & NA & Number of digits in the latitude or longitude (whichever is smaller). Used to identify whether the data is masked (value less than 5). & & \\
\hline
year & Derived & NA & Year partition in which the data point was downloaded (not necessarily the year of the capture time stamp) & & \\
\hline
county\_id & Derived & NA & County where the data point is located. The county is represented by a number which can be identified at the RAMS link in the domain. & & \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer/43}{RAMS}\\
\hline
month & Derived & NA & Month partition in which the data point was downloaded (not necessarily the month of the capture time stamp) & & \\
\hline
day & Derived & NA & Day of month partition in which the data point was downloaded (not necessarily the day of the capture time stamp) & & \\
\hline
hour & Derived & NA & Hour partition in which the data point was downloaded (not necessarily the hour of the capture time stamp) & & \\
\end{longtable}

```

Connected Vehicle Metadata
:::

## Road Network Metadata {#sec-roadnetwork}

As described in the InTrans internal documentation, the CV data continuously stream into InTrans, which listens and archives data approximately every 60 seconds. The data are processed as they are archived, and part of the process involves relating the CV data to the Iowa DOT road network, as provided by the Road Asset Management System (RAMS). The road network is broken into approximately 0.1 mile segments for relating to the CV data. The CV data points are associated to the closest roadway, and the priority of a roadway for association to the CV is determined by the roadway's facility type. @tbl-roadnetwork provides names and descriptions of the fields used to match the CV data to the road system, as described in the InTrans internal documentation.

:::{#tbl-roadnetwork}

```{=latex}
\begin{longtable}[c]{|p{0.25\textwidth}|p{0.08\textwidth}|p{0.1\textwidth}|p{0.25\textwidth}|p{0.15\textwidth}|}
\hline
 %\multicolumn{5}{| c |}{Beginning of Table}\\
 %\hline
 Field & Source & Units & Description & Domains\\
 \hline
 \endfirsthead
 
\hline
 \multicolumn{5}{|c|}{Continued from previous page}\\
 \hline
 Field & Source & Units & Description & Domains\\
 \hline
 \endhead

\hline
\endfoot

\hline
%\multicolumn{5}{| c |}{End of Table}\\
%\hline\hline
\endlastfoot

route\_id & RAMS & NA & Unique identifier for a route. The segmentation is based on the Iowa DOT’s \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer}{RAMS network}. &  \\
\hline
route\_from\_measure & RAMS & Miles & \textbf{Do not recommend using.} This field is the minimum measure for a route, but does not represent the actual location of the segment. & \\
\hline
route\_to\_measure & RAMS & Miles & \textbf{Do not recommend using.} This field is the maximum measure for a route, but does not represent the actual location of the segment. & \\
\hline
segment\_start\_latitude & RAMS & Decimal degrees  & Latitude of the start of the segment along the RAMS network  & \\
\hline
segment\_start\_longitude & RAMS & Decimal degrees & Longitude of the start of the segment along the RAMS network & \\
\hline
segment\_end\_latitude & RAMS & Decimal degrees & Latitude of the end of the segment along the RAMS network & \\
\hline
segment\_end\_longitude & RAMS & Decimal degrees & Longitude of the end of the segment along the RAMS network & \\
\hline
segment\_start\_measure & RAMS & Miles & Measure at the beginning of the segment along the RAMS network. \textbf{This field should be used when relating to the CV data.} & \\
\hline
segment\_end\_measure & RAMS & Miles & Measure at the end of the segment along the RAMS network. \textbf{This field should be used when relating to the CV data.} & \\
\hline
segment\_length & RAMS & Miles & Calculated distance of the segment based on the difference between the \texttt{segment\_start\_measure} and \texttt{segment\_end\_measure} & \\
\hline
geohash\_lrs & Derived & NA & Unique identifier for a specific region on earth that can be used to identify a specific location for filtering data & \href{https://www.ibm.com/docs/en/streams/4.3.0?topic=334-geohashes}{IBM geohash documentation} \\
\hline
bearing & Derived & Degrees & Direction of the roadway in degrees (not the same as CV data), where 0 degrees is North, 90 is East, 180 is South and 270 is West. For divided or one way roadways, the bearing represents the direction of travel for vehicles. For undivded roadways, the bearing represents the primary direction (North or East) of vehicles (but vehicles can also travel in the opposite direction of the bearing). & \\
\hline
facility\_type & RAMS & NA & Type of roadway the segment is defined as in RAMS & \href{https://gis.iowadot.gov/rams/rest/services/lrs/FeatureServer/44}{RAMS facility types}\\
\end{longtable}
```

Road network metadata
:::

## Similarities Between Data from Naturalistic Driving Studies and Connected Vehicles {#sec-similarities}

NDS and CV data are very similar to each other. Both data sources provide observations from vehicle trips, including the vehicle location (latitude and longitude), speed, and heading. These data are reported frequently, usually every one to three seconds. Depending on the nature of the data acquisition systems installed in the study participants' vehicles, NDS data may include additional information that CV data do not provide, such as the DOP coefficients associated with the GPS data. However, NDS data and CV data contain the same fundamental information (location, speed, and direction of travel for the vehicle). It is also possible to acquire similar trajectory data from micromobility solutions like bicycles and scooters. 

# Overview of the Problem {#sec-problemoverview}

As we have worked with driving data, particularly the NDS data from the UNMC study, we have noticed that GPS location data can drift away from the road system, even when the DOP coefficients for the data points fall within the Excellent to Good ranges from the scale in @tbl-dop. The blue points in @fig-gps-drift are the original points returned by the GPS unit installed in a vehicle for an NDS, and the PDOP values for these points range from 1.63 to 2.36. Despite their low PDOP values, these points do not exhibit high quality GPS location data. The red points in @fig-gps-drift show the results of a manual shift of the latitude and longitude values for the blue points. GPS errors like these make geospatial analysis of the data much more challenging. 

\mh{The map-matching problem arises from the need to associate GPS points from a moving vehicle to the road system. Map-matching algorithms answer two fundamental questions: }

\mh{1. On which road is the vehicle driving?}

\mh{2. Where on the road is the vehicle driving?}

\mh{All map-matching algorithms require a geospatial representation of the road system where the vehicle trajectories in question may be assumed to have occurred. For NDS and CV driving data, it is reasonable to expect the vast majority of driving will take place on public roads. Crucially, we assume the geospatial representation of the road system maps roads to their true locations with little to no noise. }

```{r}
#| echo: false
#| eval: false
#| label: fig-gps-drift-leaflet
#| fig-caption: |
#|   Example of GPS drift and manual shifting from original points (blue) to points more in line with the road (red)  

data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

farnam <- nds_data_sf |>
  filter(drive == 23)

# We need to shift the longitude and latitude values.
#offset <- st_as_sfc("POINT(0.000065 -0.000065)", crs = "WGS84")
#offset <- st_as_sfc("POINT(0.000075 -0.000073)", crs = "WGS84")
offset <- st_as_sfc("POINT(0.00015 0.000055)", crs = "WGS84")

shifted_points <- farnam |>
  mutate(geometry = geometry + offset)

farnam_plot <- farnam |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shifted_points_plot <- shifted_points |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shift1 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.PositronNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = farnam_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot, color = "red", label = ~glue("{time_utc}"))

offset2 <- st_as_sfc("POINT(0 -0.00008)", crs = "WGS84")

before_turn <- shifted_points_plot |>
  filter(time_utc <= ymd_hms("2019-05-28 21:17:24")) |>
  mutate(geometry = geometry + offset2)

after_turn <- shifted_points_plot |>
  filter(time_utc > ymd_hms("2019-05-28 21:17:24"))

shifted_points_plot2 <- rbind(before_turn, after_turn)

shift2 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.PositronNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = farnam_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot2, color = "red")

offset3 <- st_as_sfc("POINT(0 -0.000046)", crs = "WGS84")

before_turn2 <- shifted_points_plot2 |>
  filter(time_utc <= ymd_hms("2019-05-28 21:17:23")) |>
  mutate(geometry = geometry + offset3)

after_turn2 <- shifted_points_plot2 |>
  filter(time_utc > ymd_hms("2019-05-28 21:17:23"))

shifted_points_plot3 <- rbind(before_turn2, after_turn2)

shift3 <- leaflet() |>
  addProviderTiles(provider = "CartoDB.VoyagerNoLabels",
                   options = providerTileOptions(minZoom = 20, maxZoom = 20)) |>
  addCircleMarkers(data = farnam_plot, color = "blue") |>
  addCircleMarkers(data = shifted_points_plot3, color = "red")

#shift3
```

:::{#fig-gps-drift-old}

```{r}
#| echo: false
#| eval: false 
data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

farnam <- nds_data_sf |>
  filter(drive == 23)

# We need to shift the longitude and latitude values.
#offset <- st_as_sfc("POINT(0.000065 -0.000065)", crs = "WGS84")
offset <- st_as_sfc("POINT(0.000075 -0.000073)", crs = "WGS84")

shifted_points <- farnam |>
  mutate(geometry = geometry + offset) |>
  st_set_crs("WGS84")

farnam_plot <- farnam |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

shifted_points_plot <- shifted_points |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

# Get the lines between the original points and the matched points
all_points <- bind_rows(farnam_plot, shifted_points_plot)
all_points_ls <- all_points |>
  group_by(time_utc) |>
  summarize() |>
  st_cast("LINESTRING")

farnam_bbox <- st_bbox(farnam_plot)

farnam_bbox_adj <- farnam_bbox
farnam_bbox_adj[1] <- farnam_bbox_adj[1] - 0.0001
farnam_bbox_adj[2] <- farnam_bbox_adj[2] - 0.0001
farnam_bbox_adj[3] <- farnam_bbox_adj[3] + 0.0001
farnam_bbox_adj[4] <- farnam_bbox_adj[4] + 0.0001

# USGS data
data("oma_roads")
# Make Farnam example bounding box into sf object
farnam_bbox_sf <- farnam_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the Farnam example above
poss_matches <- oma_roads |>
  st_filter(farnam_bbox_sf, .predicate = st_intersects)

gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10)+
  tm_shape(all_points_ls, bbox = farnam_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(farnam_plot, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none")+
  tm_shape(shifted_points_plot, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "shifted", group.control = "none")

gps_drift_tmap
```
Example of GPS drift and manual shifting from original points (blue) to points more in line with the road (red) 
:::

:::{#fig-gps-drift}

```{r}
#| echo: false
#| eval: true

data("nds_data")

nds_data_sf  <- nds_data |>
  st_as_sf(coords = c("gps_long", "gps_lat"), crs = "WGS84")

farnam <- nds_data_sf |>
  filter(drive == 23)

farnam_plot <- farnam |>
  filter(time_utc >= ymd_hms("2019-05-28 21:17:20"), time_utc <= ymd_hms("2019-05-28 21:17:29"))

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = farnam_plot, label = ~glue("{round(speed_mph, 2)} mph"))

offset_pt1 <- st_as_sfc("POINT(0.00018 -0.000075)", crs = "WGS84")
pt1 <- farnam_plot[1,]
shifted_pt1 <- pt1 |>
  mutate(geometry = geometry + offset_pt1)

# Use the same offset as point 1 for point 2
pt2 <- farnam_plot[2,]
shifted_pt2 <- pt2 |>
  mutate(geometry = geometry + offset_pt1)

offset_pt3 <- st_as_sfc("POINT(0.00018 -0.000073)", crs = "WGS84")
pt3 <- farnam_plot[3,]
shifted_pt3 <- pt3 |>
  mutate(geometry = geometry + offset_pt3)

offset_pt4 <- st_as_sfc("POINT(0.00018 -0.00007)", crs = "WGS84")
pt4 <- farnam_plot[4,]
shifted_pt4 <- pt4 |>
  mutate(geometry = geometry + offset_pt4)

offset_pt5 <- st_as_sfc("POINT(0.00016 -0.00003)", crs = "WGS84")
pt5 <- farnam_plot[5,]
shifted_pt5 <- pt5 |>
  mutate(geometry = geometry + offset_pt5)

offset_pt6 <- st_as_sfc("POINT(0.00015 0.00005)", crs = "WGS84")
pt6 <- farnam_plot[6,]
shifted_pt6 <- pt6 |>
  mutate(geometry = geometry + offset_pt6)

# Use the same shift for point 7
pt7 <- farnam_plot[7,]
shifted_pt7 <- pt7 |>
  mutate(geometry = geometry + offset_pt6)

offset_pt8 <- st_as_sfc("POINT(0.000145 0.00005)", crs = "WGS84")
pt8 <- farnam_plot[8,]
shifted_pt8 <- pt8 |>
  mutate(geometry = geometry + offset_pt8)

# Use the same shift for point 9
pt9 <- farnam_plot[9,]
shifted_pt9 <- pt9 |>
  mutate(geometry = geometry + offset_pt8)

offset_pt10 <- st_as_sfc("POINT(0.00014 0.00005)", crs = "WGS84")
pt10 <- farnam_plot[10,]
shifted_pt10 <- pt10 |>
  mutate(geometry = geometry + offset_pt10)

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = farnam_plot, label = ~glue("{round(speed_mph, 2)} mph")) |>
#   addCircleMarkers(data = shifted_pt1, color = "brown") |>
#   addCircleMarkers(data = shifted_pt2, color = "black") |>
#   addCircleMarkers(data = shifted_pt3, color = "darkgray") |>
#   addCircleMarkers(data = shifted_pt4, color = "darkorchid") |>
#   addCircleMarkers(data = shifted_pt5, color = "magenta") |>
#   addCircleMarkers(data = shifted_pt6, color = "red") |>
#   addCircleMarkers(data = shifted_pt7, color = "orange") |>
#   addCircleMarkers(data = shifted_pt8, color = "gold") |>
#   addCircleMarkers(data = shifted_pt9, color = "green") |>
#   addCircleMarkers(data = shifted_pt10, color = "turquoise")

manual_shift_points <- bind_rows(shifted_pt1, shifted_pt2,
                                 shifted_pt3, shifted_pt4,
                                 shifted_pt5, shifted_pt6,
                                 shifted_pt7, shifted_pt8,
                                 shifted_pt9, shifted_pt10)

manual_shift_points <- manual_shift_points |>
  st_set_crs("WGS84")

# leaflet() |>
#   addProviderTiles("CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = farnam_plot, color = "blue") |>
#   addCircleMarkers(data = manual_shift_points, color = "red")

all_shifted_points <- bind_rows(farnam_plot, manual_shift_points)
all_shifted_points_ls <- all_shifted_points |>
  group_by(time_utc) |>
  summarize() |>
  st_cast("LINESTRING")

farnam_bbox <- st_bbox(farnam_plot)

farnam_bbox_adj <- farnam_bbox
farnam_bbox_adj[1] <- farnam_bbox_adj[1] - 0.0002
farnam_bbox_adj[2] <- farnam_bbox_adj[2] - 0.0002
farnam_bbox_adj[3] <- farnam_bbox_adj[3] + 0.0002
farnam_bbox_adj[4] <- farnam_bbox_adj[4] + 0.0002

# USGS data
data("oma_roads")
# Make Farnam example bounding box into sf object
farnam_bbox_sf <- farnam_bbox |>
  st_as_sfc() |>
  st_as_sf(crs = "WGS84")

# Find road candidates within the bounding box for the Farnam example above
poss_matches <- oma_roads |>
  st_filter(farnam_bbox_sf, .predicate = st_intersects)

gps_drift_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10)+
  tm_shape(all_shifted_points_ls, bbox = farnam_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(farnam_plot, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(manual_shift_points, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "shifted", group.control = "none", fill_alpha = 0.9)

gps_drift_tmap
```
Example of GPS drift and manual shifting from original points (blue) to points more in line with the road (red) 
:::

There are many map-matching algorithms available, ranging from simple to complex. A simple way to solve the GPS drift problem would be to orthogonally project the GPS points onto the nearest road. @sakiPracticalGuideOpenSource2022 noted that this method was used by @bernsteinIntroductionMapMatching1996, @whiteMapMatchingAlgorithms2000, and @taylorRoadReductionFiltering2001. This method is fast, but @sakiPracticalGuideOpenSource2022 note that it is sensitive to outliers. 

@fig-naive-map-matching shows a shortcoming of orthogonally projecting GPS points onto the nearest road segment using the same example as @fig-gps-drift. Once again, the original points are blue and the matched points are red. The orthogonal projection looks good for six of the ten points, but the four points west of the intersection are problematic. The original points may be closer to the east-west road segment instead of the north-south road segment, but the match does not fit with the rest of the vehicle trajectory.

:::{#fig-naive-map-matching}

```{r}
#| echo: false

# leaflet() |>
#   addProviderTiles(provider = "CartoDB.Positron") |>
#   addCircleMarkers(data = farnam_plot, color = "black") |>
#   addPolygons(data = farnam_bbox_sf) |>
#   addPolylines(data = poss_matches, color = "red")
# The road candidates are what we would expect.

# For each GPS point, find the nearest point on each of the road segments
nearest_pts_ls <- st_nearest_points(farnam_plot, poss_matches)

nearest_pts_ls_sf <- st_as_sf(nearest_pts_ls)

# Find the distance between the original point and the matched point
nearest_pts_ls_sf <- nearest_pts_ls_sf |>
  rename(geometry = x) |>
  mutate(dist = st_length(geometry))

nearest_pts_ls_sf_start <- lwgeom::st_startpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

nearest_pts_ls_sf_end <- lwgeom::st_endpoint(nearest_pts_ls_sf) |> 
  st_as_sf() |>
  rename(geometry = x)

# For each starting point, find the closest matched point
nearest_pts_end_match <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(farnam_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id) |>
  filter(dist == min(dist))

# Get the lines between the original points and the matched points
nearest_pts_ls_match <- nearest_pts_ls_sf |>
  mutate(id = rep(1:nrow(farnam_plot), each = nrow(poss_matches))) |>
  group_by(id) |>
  filter(dist == min(dist))

# leaflet() |>
#   addProviderTiles(provider = "CartoDB.VoyagerNoLabels") |>
#   addPolylines(data = nearest_pts_ls_sf, color = "blue") |>
#   addCircleMarkers(data = nearest_pts_ls_sf_start, color = "green") |>
#   addCircleMarkers(data = nearest_pts_ls_sf_end, color = "orange")

# mm_process_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
#      tm_shape(poss_matches, bbox = farnam_bbox_adj)+
#      tm_lines(col = "tan", lwd = 10)+
#      tm_shape(nearest_pts_ls_sf, bbox = farnam_bbox_adj) +
#      tm_lines(col = "black")+
#      tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
#      tm_dots(size = 1, fill = "blue", group = "original", group.control = "none")
     
# leaflet() |>
#   addProviderTiles(provider = "CartoDB.VoyagerNoLabels") |>
#   addCircleMarkers(data = nearest_pts_start, color = "blue") |>
#   addCircleMarkers(data = nearest_pts_end_match, color = "red")

mm_tmap <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_match, bbox = farnam_bbox_adj)+
  tm_lines(col = "black")+
  tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(nearest_pts_end_match, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap 
```
Example of the shortcomings of naively orthogonally projecting GPS points (blue) onto the nearest road segment (red). Note the four nonsensically matched red points west of the intersection.
:::

```{r}
#| include: false
# Find the distance between consecutive matched points
# Create new dataset that is shifted by 1 index
nearest_pts_end_match_shift <- nearest_pts_end_match[-1,]
# Repeat the last point so st_distance doesn't throw an error
nearest_pts_end_match_shift <- rbind(nearest_pts_end_match_shift, nearest_pts_end_match_shift[nrow(nearest_pts_end_match_shift),])

match_consec_dists <- st_distance(x = nearest_pts_end_match,
                                  y = nearest_pts_end_match_shift,
                                  by_element = TRUE
                                  )
# There is a big jump between points 7 and 8.
```

```{r}
#| include: false
farnam_plot_matched_og <- farnam_plot |>
  st_set_geometry(st_geometry(nearest_pts_end_match))

nearest_pts_dist <- nearest_pts_ls_sf_end |>
  mutate(id = rep(1:nrow(farnam_plot), each = nrow(poss_matches)),
         dist = nearest_pts_ls_sf$dist) |>
  group_by(id)

# Manually replace the 7th point with the next closest point
farnam_plot_matched_alt7 <- farnam_plot_matched_og
#farnam_plot_matched_alt7$geometry[7] <- lwgeom::st_endpoint(nearest_pts_ls_sf$geometry[19])
farnam_plot_matched_alt7$geometry[7] <- nearest_pts_dist$geometry[19]

mm_tmap_alt7 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(farnam_plot_matched_alt7, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt7
```

```{r}
#| include: false
# Manually replace the sixth point with the next closest point
farnam_plot_matched_alt76 <- farnam_plot_matched_alt7
farnam_plot_matched_alt76$geometry[6] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[16])

mm_tmap_alt76 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(farnam_plot_matched_alt76, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt76
```

```{r}
#| include: false
# Manually replace the fifth point with the next closest point
farnam_plot_matched_alt765 <- farnam_plot_matched_alt76
farnam_plot_matched_alt765$geometry[5] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[15])
# The exact point may not matter here because it's matching to the endpoint shared by 2 segments.

mm_tmap_alt765 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(farnam_plot_matched_alt765, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt765
```

```{r}
#| echo: false
# Manually replace the fourth point with the next closest point
farnam_plot_matched_alt7654 <- farnam_plot_matched_alt765
farnam_plot_matched_alt7654$geometry[4] <- lwgeom::st_endpoint(nearest_pts_dist$geometry[12])
# The exact point may not matter here because it's matching to the endpoint shared by 2 segments.

# Now the fourth and fifth points are on top of each other at the corner.

# Get the lines between the original points and the matched points
alt_points <- bind_rows(farnam_plot, farnam_plot_matched_alt7654)
alt_points_ls <- alt_points |>
  group_by(time_utc) |>
  summarize() |>
  st_cast("LINESTRING")


farnam_plot_matched_alt7654_ls <- 
  map2(.x = farnam_plot$geometry, .y = farnam_plot_matched_alt7654$geometry,
       \(x, y) st_union(x, y) |> st_cast("LINESTRING")) |>
  st_as_sfc() |>
  st_as_sf()

farnam_plot_matched_alt7654_ls <- farnam_plot_matched_alt7654_ls |>
  rename(geometry = "x")

mm_tmap_alt7654 <- tm_basemap(server = "CartoDB.VoyagerNoLabels")+
  tm_shape(poss_matches, bbox = farnam_bbox_adj)+
  tm_lines(col = "tan", lwd = 10) +
  tm_shape(alt_points_ls, bbox = farnam_bbox_adj) +
  tm_lines(col = "black")+
  tm_shape(nearest_pts_ls_sf_start, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "blue", group = "original", group.control = "none", fill_alpha = 0.9)+
  tm_shape(farnam_plot_matched_alt7654, bbox = farnam_bbox_adj)+
  tm_dots(size = 1, fill = "red", group = "matched", group.control = "none", fill_alpha = 0.9)

mm_tmap_alt7654
```

Another matching method used by several authors (including @krakiwskyKalmanFilterIntegrating1988 and @scottIncreasedAccuracyMotor1994) and discussed by @sakiPracticalGuideOpenSource2022 is to fit a curve through a sequence of GPS points and find the road segments that best match the curve. @sakiPracticalGuideOpenSource2022 observed that this curve-fitting approach worked well in some special cases, but performed poorly in most real-world applications. If heading information is available for the vehicle and the road system, it can be used to check the quality of matches, as @sakiPracticalGuideOpenSource2022 noted was done by @bernsteinIntroductionMapMatching1996 and @whiteMapMatchingAlgorithms2000. It is reasonable to assume that the heading of a vehicle traveling on a road should be similar to the heading of the road, so roads should be removed from consideration if the vehicle heading and the road heading disagree, as noted by @sakiPracticalGuideOpenSource2022. @sakiPracticalGuideOpenSource2022 observed that @yangImprovedMapmatchingAlgorithm2003 and @quddusGeneralMapMatching2003 used Kalman filters to drop unreasonable GPS points and achieve better map-matching results.

Map-matching with hidden Markov models (HMMs) was introduced by @newsonHiddenMarkovMap2009, whose algorithm performed map matching using a hidden Markov model to find the most likely route on the road system corresponding to a time-stamped set of GPS coordinates while accounting for noisy data and the configuration of the road network. However, @newsonHiddenMarkovMap2009's algorithm was not a real-time algorithm. Hidden Markov models are a common basis for many later map-matching algorithms [@sakiPracticalGuideOpenSource2022].

@chaoSurveyMapMatchingAlgorithms2020 surveyed available map-matching algorithms and noted that state-transition models are a popular model type. These include hidden Markov models (HMMs) and conditional random field (CRF) models. CRF models models account for interactions among observations while HMMs only consider the relationship between an observation and the most recent previous point [@chaoSurveyMapMatchingAlgorithms2020]. Weighted graph techniques can be used to infer the path from a weighted graph where the vertices are candidate points on the road system and edges are formed between two consecutive sample points. Weighted graph techniques tend to involve the following steps: (1) Initialize the graph (2) Use a scoring function to weight the edges in the graph (3) Infer the path based on the weighted graph [@chaoSurveyMapMatchingAlgorithms2020].

As mentioned above, map-matching algorithms can suffer from data quality issues, as observed by @chaoSurveyMapMatchingAlgorithms2020. When the sampling rate is high, unnecessary detours can occur. This means that consecutive points may be too close to each other, so the later point is mapped in the upstream of the previous point. State-transition models, in particular, can suffer from matching breaks caused by outliers. The outlier point falls out of the candidate range for the true state, and so the map-matching route disconnects [@chaoSurveyMapMatchingAlgorithms2020]. Evaluating the accuracy of any map-matching algorithm is challenging because the true path taken by the vehicle is unknown [@sakiPracticalGuideOpenSource2022]. 

\mh{@newsonHiddenMarkovMap2009 provide one example vehicle trajectory from a route in Seattle, Washington, USA, along with the ground truth route traveled by the vehicle. @kubickaDatasetTestingTraining2015 provide one hundred example vehicle trajectories from various locations around the world along with a map-matched route for each trajectory. However, the true sequence of road segments traveled in each of these trajectories are unknown, and thus the matched routes represent experts' best ideas for the correct sequence of road segments. The sets of example trajectories from @newsonHiddenMarkovMap2009 and @kubickaDatasetTestingTraining2015 deal more with the determination of the road segment on which the vehicle was traveling at each time point as opposed to the location of the vehicle on the selected link.}

# References

\sloppy
<!-- Inspired by https://github.com/jgm/pandoc/issues/10921 -->

::: {#refs}
:::
